> 本文参考
>
> [力扣 (LeetCode)](https://leetcode-cn.com/leetbook/read/bit-manipulation-and-math) 

# 1. 位运算和数学

## 1.1 进制

### 1.1.1 概念

十进制的 123.45 可以写成如下形式：

$123.45 = 1 \times 10^2 + 2 \times 10^1 + 3 \times 10^0 + 4 \times 10^{-1} + 5 \times 10^{-2}$

八进制的 720.5 可以写成如下形式：

$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1}$



### 1.1.2 进制转换

- **转成十进制**：八进制数 $720.5_{(8)}$**转成十进制**：

$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1} = 464.625$



- **整数转成非十进制**：十进制数 50 **转成二进制**：
  50÷2=25 余 0
  25÷2=12 余 1
  12÷2=6 余 0
  6÷2=3 余 0
  3÷2=1 余 1
  1÷2=0 余 1

**反向遍历**每次的余数，依次是 1,1,0,0,1,0，因此十进制数 50 转成二进制数是 $110010_{(2)}$



- **小数转成非十进制**：十进制数 **0.6875 转成二进制**：
  0.6875×2=1.375 整 1
  0.375×2=0.75 整 0
  0.75×2=1.5 整 1
  0.5×2=1 整 1

**正序遍历**每次的整数部分，依次是 1,0,1,1，因此十进制数 0.6875 转成二进制数是 $0.1011_{(2)}$



**其他进制间的转换**
如果需要在两个不同的非十进制之间转换，常规的思路是**先转成十进制数**，**再转成目标进制数**。在一些特殊情况下，也可以不经过十进制，直接进行转换。

例如，将二进制数转成八进制数或十六进制数，以及将八进制数或十六进制数转成二进制数，都不需要经过十进制。**一位八进制数可以表示成三位二进制数**，**一位十六进制数可以表示成四位二进制数**。

- **二转八**：对于二进制数 $101110010_{(2)}$  ，按照三位一组进行分组，可以得到 101|110|010，因此转成八进制数是 $562_{(8)}$

- **二转十六**：按照四位一组进行分组，可以得到1∣0111∣0010，转成十六进制数是 $172_{(16)}$



例题：[七进制](https://leetcode-cn.com/problems/base-7/solution/), 





## 1.2 整数表示

### 1.2.1 有符号和无符号整数

- 有符号整数：最高位表示符号，最高位0表示整数，1表示负数。
  - 以 1 字节为例，1 字节包含8为二进制。最高位为0时，1 字节取值范围0~127（$2^7 -1$）。最高位为 1 时，1 字节的取值范围 -128 ($- 2^7$)  ~  -1。则 1 字节取值范围 -128 ~ 127  （$- 2^7 \sim 2^7-1$）
- 无符号整数：虽有位表示数字大小
  - 数值范围：0 ~ 255 ($2^8 - 1$)

对于 k 位整数，有符号整数的取值范围是 $-2^{k-1}$ 到 $2^{k-1} - 1$，无符号整数的取值范围是 0 到 $2^k-1$。



**int的最小值**表示`-1 << 31`等价于`-2147483648`

### 1.2.2 原码
原码是机器数的符号位加上机器数的真值的绝对值，最高位是符号位，其余位表示数值。

以 8 位二进制数为例。

- +10 的原码是 00001010，

- -10 的原码是 10001010。

8位二进制数的原码表示的最大值是 01111111，即十进制的 +127，最小值是 11111111，即十进制的 -127，因此 8 位二进制数的原码表示的取值范围是 -127 到 +127。

### 1.2.3 反码
反码在原码的基础上得到。

0 和**正数的反码与原码相同**，**负数**的反码是**将原码的除了符号位之外的每一位取反**，取反即为将 0 变成 1 或将 1 变成 0。

以 8 位二进制数为例。

- +10 的原码是 00001010，反码是 000010100；

- -10 的原码是 10001010，反码是 11110101。

### 1.2.4 补码

补码在反码的基础上得到。

**0** 和**正数的补码与原码、反码相同**，**负数**的补码是在**反码的基础上加 1** 得到。

以 8 位二进制数为例。

- +10 的原码是 00001010，反码是 00001010，补码是 00001010；

- -10 的原码是 10001010，反码是 11110101，补码是 111101101。



### 1.2.5 原码反码补码存在原因

但是**原码存在两个问题**：

- 同时存在 +0（即符号位和其余位都是 0）和 -0（即符号位是 1，其余位都是 0）的表示，虽然可以认为 **+0 和 -0 是同一个数**，但是 0 带符号是没有意义的，而且会导致有**两个不同的原码都对应 0**；

- 用原码进行**减法**运算，会导致**错误**的结果。

**反码的引入**，**解决了原码的减法运算结果错误**的问题，但是仍然没有解决同时存在 +0 和 −0 的问题。

**补码的引入**则**同时解决了减法运算错误**和**同时存在 +0 和 -0 的问题**，**而且可以多表示一个最小值**。

- 在补码表示法中，不存在 -0 的情况。以 8 位二进制数为例，0 的补码是 00000000，10000000 表示的是 −128，
- −128 没有原码和反码的表示（8 位二进制数的原码和反码能表示的最小值是 -127）。由此可见，补码不仅解决了原码和反码的问题，还可以**多表示一个最小值-128**。

由于补码具有上述优点，因此**计算机采用补码进行运算**



## 1.3 位运算概述

计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。

位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。上述位运算中，只有取反是一元运算，其余的都是二元运算。

**与、或、异或和取反**
与运算的符号是 \&，运算规则是：对于每个二进制位，当两个数对应的位都为 1 时，结果才为 1，否则结果为 0。
0 & 0=0
0 & 1=0
1 & 0=0
1 & 1=1

或运算的符号是 ∣，运算规则是：对于每个二进制位，当两个数对应的位都为 0 时，结果才为 0，否则结果为 1。
0 ∣ 0=0
0 ∣ 1=1
1 ∣ 0=1
1 ∣ 1=1

异或运算的符号是 ⊕（在代码中用 ∧ 表示异或），运算规则是：对于每个二进制位，当两个数对应的位相同时，结果为 0，否则结果为 1。
0⊕0=0
0⊕1=1
1⊕0=1
1⊕1=0

取反运算的符号是 ∼，运算规则是：对一个数的每个二进制位进行取反操作，0 变成 1，1 变成 0。
∼0=1
∼1=0

以下例子显示上述四种位运算符的运算结果，参与运算的数字都采用有符号的 8 位二进制表示。

46 的二进制表示是 00101110，51 的二进制表示是 00110011。考虑以下位运算的结果。

46 & 51 的结果是 34，对应的二进制表示是 00100010。

46 ∣ 51 的结果是 63，对应的二进制表示是 00111111。

46⊕51 的结果是 29，对应的二进制表示是 00011101。

∼46 的结果是 −47，对应的二进制表示是 11010001。

∼51 的结果是 −52，对应的二进制表示是 11001100。

### 1.3.1 移位运算

移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。

左移运算的符号是 <<。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。

右移运算的符号是 >>。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：

算术右移时，高位补最高位；

逻辑右移时，高位补 0。

以下例子显示移位运算的运算结果，参与运算的数字都采用有符号的 88 位二进制表示。

29 的二进制表示是 00011101。29 左移 2 位的结果是 116，对应的二进制表示是 01110100；29 左移 3 位的结果是 −24，对应的二进制表示是 11101000。

50 的二进制表示是 00110010。50 右移 1 位的结果是 25，对应的二进制表示是 00011001；50 右移 2 位的结果是 12，对应的二进制表示是 00001100。对于 0 和正数，算术右移和逻辑右移的结果是相同的。

-50 的二进制表示是 11001110。-50 算术右移 2 位的结果是 −13，对应的二进制表示是 11110011；−50 逻辑右移 2 位的结果是 51，对应的二进制表示是 00110011。

右移运算中的算术移位和逻辑移位是不同的，计算机内部的右移运算采取的是哪一种呢？

对于 C/C++ 而言，数据类型包含有符号类型和无符号类型，其中有符号类型使用关键字 signed 声明，无符号类型使用关键字 unsigned 声明，两个关键字都不使用时，默认是有符号类型。对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。

对于 Java 而言，不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。在 Java 中，算术右移的符号是 >>，逻辑右移的符号是 >>>。

### 1.3.2 移位运算与乘除法的关系

观察上面的例子可以看到，移位运算与乘除法有密切的关联性。由于计算机的底层的一切运算都是基于位运算实现的，因此使用移位运算实现乘除法的效率显著高于直接乘除法的效率。

左移运算对应乘法运算。将一个数左移 k 位，等价于将这个数乘以 $2^k$
 。例如，29 左移 2 位的结果是 116，等价于 29×4。当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和，例如，a×6 等价于 (a<<2)+(a<<1)。对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。

算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 $2^k$  。例如，50 右移 2 位的结果是 12，等价于 50/4，结果向下取整。

从程序实现的角度，考虑程序中的整数除法，是否可以说，将一个数（算术）右移 k 位，和将这个数除以 $2^k$等价？对于 0 和正数，上述说法是成立的，整数除法是向 0 取整，右移运算是向下取整，也是向 0 取整。但是对于负数，上述说法就不成立了，整数除法是向 0 取整，右移运算是向下取整，两者就不相同了。例如，(−50)>>2 的结果是 -13，而 (−50)/4 的结果是 −12，两者是不相等的。

因此，将一个数（算术）右移 k 位，和将这个数除以 $2^k$ 是不等价的。



### 1.3.3 位运算的性质

位运算的性质有很多，此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。

幂等律：a & a=a，a ∣ a=a（注意异或不满足幂等律）；

交换律：a & b=b & a，a ∣ b=b ∣ a，a⊕b=b⊕a；

结合律：(a & b) & c=a & (b & c)，(a ∣ b) ∣ c=a ∣ (b ∣ c)，(a⊕b)⊕c=a⊕(b⊕c)；

分配律：(a & b) ∣ c=(a ∣ c) & (b ∣ c)，(a ∣ b) & c=(a & c) ∣ (b & c)，(a⊕b) & c=(a & c)⊕(b & c)；

德·摩根律：∼(a & b)=(∼a) ∣ (∼b)，∼(a ∣ b)=(∼a) & (∼b)；

取反运算性质：−1=∼0,  −a=∼(a−1)；

与运算性质：a & 0=0，a & (−1)=a，a & (∼a)=0；

或运算性质：a ∣ 0=a，a ∣ (∼a)=−1；

异或运算性质：a⊕0=a，a⊕a=0；

其他性质：

a & (a−1) 的结果为将 a 的二进制表示的最后一个 1 变成 0；

a & (−a)（与 a & (∼(a−1)) 等价）的结果为只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0。

利用上述性质，可以巧妙地解决很多位运算的题目。



## 1.4 例题及常用解法

### 1.4.1 取出二进制数下几个位

`num & 0x1`通过数字`&`一个所需位为1，其余位为0的二进制后得到所需的位

取`1`位用`0x1`,取`2`位用`0x3`,取`3`位用`0x7`,取`4`位用`0xf`

所有的取的位都是最低几位，取高位需要用`num >>> i`将数值逻辑右移`i`位后再取



[数字转十六进制](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/)

```java
int num = 30;
for (int i = 7; i >= 0; i--) {
    int val = (num >> (4 * i)) & 0xf; // 从最高位开始，每四位取出一次转化为16进制
    if (sb.length() > 0 || val > 0) {
        char digit = hexChar(val);
        sb.append(digit);
    }
}
```

[二进制数中位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/solution/)

```java
	public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            count += (n >> i) & 1;
        }
        return count;
    }
```

[颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/solution/)

解法一：逐位颠倒

```java
    public int reverseBits(int n) {
        int reversed = 0, power = 31;
        while (n != 0) {
            reversed += (n & 1) << power; // 逐位颠倒，求出每一位并左移相应位置，再相加
            n >>>= 1;
            power--;
        }
        return reversed;
    }
```

解法二：每一行分别将 n 分成 16 位、8 位、4 位、2 位、1 位的块，即把每个块分成两个较小的块，并将分成的两个较小的块颠倒。

`n & 0xff00ff00`留下 n 的8~15, 24~31位

```java
    public int reverseBits(int n) {
        n = (n >>> 16) | (n << 16); // 对半左右颠倒
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8); // 8位划分左右颠倒
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
        return n;
    }
```



[区间内所有数字 按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/)

本质上：找出两个二进制相同前缀

```java
    public int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        // 找到公共前缀
        while (m < n) {
            m >>= 1;
            n >>= 1;
            ++shift;
        }
        return m << shift;
    }
```



### 1.4.2 二进制的`num`第 `i` 位取反

`num` 异或 `i`位为`1`其余位为`0`的值，

此时其余位与`0`异或不变，第`i`位于`1`异或取反

​    1101

⊕ 0100

-------

​     1001

```java
 num ^ (1 << i-1) 
```



### 1.4.3 a & (a−1) 

a & (a−1) 的结果为将 a 的二进制表示的最后一个 1 变成 0；

[二进制数中位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/solution/)

```java
	public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
    }
```

[区间内所有数字 按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/)

```java
    public int rangeBitwiseAnd(int m, int n) {
        while (m < n) {
            // 抹去最右边的 1
            n = n & (n - 1);
        }
        return n;
    }
```







### 1.4.4 a⊕0=a，a⊕a=0

异或运算性质：a⊕0=a，a⊕a=0；

[只出现一次的数字](https://leetcode-cn.com/problems/single-number/solution/)

除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素

```java
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int e:nums){
            ans ^= e;
        }
        return ans;
    }
```

### 1.4.5 a & (−a)

a & (−a)（与 a & (∼(a−1)) 等价）

结果为只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0。

a      00001010

& -a 11110110

​        00000010 只保留了最后一位1

[只出现一次的数字（三）](https://leetcode-cn.com/problems/single-number-iii)

恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素

```
[1,2,1,3,2,5]  
不同两个[3,5]
```

```java
    public int[] singleNumber(int[] nums) {
        int mask = 0;
        for(int e: nums){  // 1. 筛出所有重复元素
            mask ^= e;
        }
        mask &= (-mask);  // 2. 找出两个不同数异或后结果中为1的位，其余位都为0
        // 两个数异或后为1说明，两个数该位置分别为0，1，根据这个区分出两个数

        int[] ans = new int[2];
        for(int e: nums){
            // 当该位为1与所有数与，得出结果为0的，则该位为0的所有数归一类，这一类里面包含出现一次的一个元素 和 成对出现的所有该位为0的数，这些数成对出现异或后则为0，则筛出的数为只出现一次的数
            // 得出结果为1的，则该位为1的所有数归一类
            if( (mask & e) == 0 ){
                ans[0] ^= e;
            }else{
                ans[1] ^= e;
            }
        }
        return ans;
    }
```





### 1.4.6 数字转化为字符

0 --> '0'

10 --> 'a'

```java
    public char hexChar(int num) {
        if (num < 10) {
            return (char) (num + '0');
        } else {
            return (char) (num - 10 + 'a');
        }
    }
```



### 1.4.7 两数求和用位运算

[两数求和用位运算](https://leetcode-cn.com/problems/sum-of-two-integers/solution/)

```java
    public int getSum(int a, int b) {
        while(a != 0){
            int tmp = a ^ b;
            a = (a & b) << 1;
            b = tmp;
        }
        return b;
    }
```





## 1.4 状态压缩

### 1.4.1 状态压缩定义

状态压缩，顾名思义就是将多个值的状态压缩成一个数字。具体而言，如果有 n 个值，每个值有 2 种可能的状态，则状态总数有 $2^n$ 个，可以用一个 n位二进制数记录全部 n 个状态的取值。

例如，一共有 n 个物品，每个物品分别对应一个值，即该物品是拿还是不拿，可以用一个 n 位二进制数表示每个物品的值。当 n=5 时，假设二进制数从最低位到最高位依次表示第 1 个物品到第 5 个物品是拿还是不拿，1 表示拿，0 表示不拿，则 $01011_{(2)}$

  表示拿了第 1 个、第 2 个和第 4 个物品，不拿第 3 个和第 5 个物品。

### 1.4.2 状态压缩的适用场景

如果每个值都有 2 种状态，n 个值对应的状态总数就是 $2^n$，因此只有当 n 较小时，才能适用状态压缩。一般而言，当 n≤20 时，可以考虑状态压缩。

### 1.4.3 状态压缩动态规划

虽然状态压缩的适用场景是数据规模小的情况，但是如果使用回溯等暴力方法求解，仍然可能导致时间复杂度过高，例如对同一种状态重复求解，结果超出时间限制。因此，状态压缩常用于动态规划，使用动态规划就可以避免重复计算的情况。

使用到状态压缩的动态规划称为状态压缩动态规划，是动态规划中最难的一类问题。

动态规划的三个要素是：状态表示、状态转移方程和边界情况，其中，状态表示和状态转移方程是很多动态规划问题的难点，对于状态压缩动态规划，需要使用状态压缩的方式进行状态表示，因此进一步增加了问题的难度。

使用状态压缩动态规划求解时，需要充分考虑状态应该如何表示以及状态之间的关联，得到合适的状态表示和状态转移方程。



## 1.4 bitMap与bitSet

详见：https://www.cnblogs.com/cjsblog/p/11613708.html

Bit-map的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此在**存储空间方面，可以大大节省**

**大量数据的快速排序、查找、去重**



bitSet()在java中内置了，https://tool.oschina.net/apidocs/apidoc?api=jdk-zh



布隆过滤器：Bloom filter 是一个数据结构，它可以用来**判断某个元素是否在集合内**，具有运行快速，内存占用小的特点。

而高效插入和查询的代价就是，Bloom Filter 是一个基于概率的数据结构：它只能告诉我们一个元素**绝对不在集合内**或**可能在集合内**。

http://llimllib.github.io/bloomfilter-tutorial/zh_CN/



## 1.5 数学

### 1.5.1 幂运算

实现 [pow(x, n)](https://leetcode-cn.com/problems/powx-n/solution/)

解法一：递归

```java
    public double myPow(double x, int n) {
        if(n >= 0){
            return pow(x, n);
        }else{
            if(n == -2147483648){
                return  (1/x) * ( 1/ pow(x, -(n+1) ) );
            }
            return 1.0 / pow(x, -n);
        }
    }

    public double pow(double x, int n){
        if(n == 0){
            return 1;
        }else if(n == 1){
            return x;
        }else{
            if( n % 2 == 0){
                double ans = pow(x, n/2);
                return ans * ans;
            }else{
                double ans = pow(x, (n-1)/2);
                return x * ans * ans;
            }
        }
    }

```

解法二：迭代

```java
    public double myPow(double x, int n) {
        long nLong = n;
        return nLong >= 0 ? quickMul(x, nLong) : 1.0 / quickMul(x, -nLong);
    }

    public double quickMul(double x, long n) {
        double ans = 1.0;
        while (n > 0) {
            if (n % 2 == 1) {
                ans *= x;
            }
            x *= x;
            n /= 2;
        }
        return ans;
    }
```

### 1.5.2 判断幂运算

- 判断该整数是否是 `2` 的[幂次方](https://leetcode-cn.com/problems/power-of-two/solution/)

通过`n&(n-1) == 0`去判断，`2`的幂次方则二进制只有一个位为 `1`

```java
    public boolean isPowerOfTwo(int n) {
        return n>0 && ( (n&(n-1)) == 0 );
    }
```



- 判断该整数是否是 `3` 的[幂次方](https://leetcode-cn.com/problems/power-of-three/solution/)

由于给定的输入 n 是 int 型，其最大值为 $2^{31}$，因此在int 型的数据范围内存在最大的 3 的幂，不超过 $2^{31}$的最大的 3 的幂是 $3^{19}=1162261467

如果 n 是 3 的幂，则 n>0，且存在非负整数 k 使得 $n=3^k$，又由于 $n \le 3^{19}$ ，因此 $k \le 19$，$3^{19}$ 一定能被 n 整除：$\frac{3^{19}}{n}=\frac{3^{19}}{3^k}=3^{19-k}$  为正整数。

如果 n 不是 3 的幂，则 n 一定包含除了 3 以外的质因数，又由于 $3^{19}$ 的质因数只有 3，因此 $3^{19}$ 不能被 n 整除。

综上所述，对于 int 型的 n，n 是 3 的幂，当且仅当 n>0 且 $3^{19}$ 能被 n 整除。

```java
    public boolean isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
```



- 判断该整数是否是 `4` 的幂次方

  [4次幂](https://leetcode-cn.com/problems/power-of-four/solution/)

正整数 n 是 2 的幂，当且仅当 n 的二进制表示中只有最高位是 1，其余位都是 0。如果 n 的二进制表示中只有最高位是 1，最高位后面有偶数个 0，则 n 是 4 的幂。

如何判断 n 是否满足最高位后面有偶数个 0 呢？可以通过位运算判断。如果 n 是 4 的幂，则有 $n \oplus 1010 \ldots 1010_{(2)}=0$，其中 ⊕ 表示按位异或，$1010 \ldots 1010_{(2)}=aaaaaaaa_{(16)}$ 

```java
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;
    }
```



### 1.5.3几何矩形重叠

- 判断[两个矩形是否重叠]( https://leetcode-cn.com/problems/rectangle-overlap/solution/)

只有当两个矩形的面积都大于 0 时，两个矩形才可能重叠。两个矩形的面积都大于 0 的条件是：

$\textit{rec}_1[0]<\textit{rec}_1[2]$

$\textit{rec}_1[1]<\textit{rec}_1[3]$

$\textit{rec}_2[0]<\textit{rec}_2[2]$

$\textit{rec}_2[1]<\textit{rec}_2[3]$
水平方向的坐标范围重叠，等价于 $\textit{rec}_1[2]>\textit{rec}_2[0]$ 且 $\textit{rec}_1[0]<\textit{rec}_2[2]$

竖直方向的坐标范围重叠，等价于 $\textit{rec}_1[3]>\textit{rec}_2[1]$且 $\textit{rec}_1[1]<\textit{rec}_2[3]$

```java
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if (rec1[0] == rec1[2] || rec1[1] == rec1[3] || rec2[0] == rec2[2] || rec2[1] == rec2[3]) {
            return false;
        }
        return rec1[2] > rec2[0] && rec1[0] < rec2[2] && rec1[3] > rec2[1] && rec1[1] < rec2[3];
    }
```

- 求两个矩形[重叠面积](https://leetcode-cn.com/problems/rectangle-area/solution/)

计算两个矩形的重叠部分的面积，可以利用[836. 矩形重叠](https://leetcode-cn.com/leetbook/read/bit-manipulation-and-math/on1nf3/)的思路，在判断两个矩形是否重叠的同时计算重叠部分的面积。

第一个矩形的左下角坐标是 (A,B)，右上角坐标是 (C,D)。第二个矩形的左下角坐标是 (E,F)，右上角坐标是 (G,H)

重叠部分的水平方向长度是 min(C,G) − max(A,E)；

重叠部分的竖直方向长度是 min(D,H) − max(B,F)。

```java
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int hg = 0, lg = 0;
        if( (ax1<bx2) && (ax2 > bx1) && (ay1 < by2) && (ay2 > by1) ){
        	hg = Math.min(ay2,by2) - Math.max(ay1,by1);
        	lg = Math.min(ax2,bx2) - Math.max(ax1,bx1);
        }
        int s1 = (ax2-ax1) * (ay2-ay1);
        int s2 = (bx2-bx1) * (by2-by1);
        return s1 + s2 - hg*lg;

    }
```



### 1.5.4 质数

**质数定义**
质数也称素数，其定义是：一个大于 1 的正整数，除了 1 和它自身以外没有其他的因数，则这个正整数为素数。

如果一个正整数除了 1 和它自身以外还有其他的因数，则这个正整数为合数。

1 既不是质数，也不是合数，而是单独的一类。

**质数的判定**
由于 11 既不是质数也不是合数，因此对于 1 可以直接判断其不是质数。以下只考虑对于大于 1 的正整数判定是不是质数。

如果正整数 n 是合数，则一定存在正整数 x,y，满足 1<x≤y 且 $x \times y=n$。由于 x≤y，因此一定有 $x \le \sqrt{n} \le y$，即如果正整数 n 是合数，一定存在正整数 x 满足 $1<x \le \sqrt{n}$且 x 能整除 n。

要判断一个正整数 n 是合数还是质数，只要遍历所有大于 1 且小于 $\sqrt{n}$  的正整数 x，判断是否存在正整数 x 可以整除 n，只要找到一个这样的 x，则 n 就是合数，否则 n 是质数。

具体实现方面可以进一步优化。由于 2 是偶数中唯一的质数，因此首先判断 n 的奇偶性，当 n 是偶数时根据 n 是否等于 2 判断 n 是质数还是合数，当 n 是奇数时再寻找可以整除 n 的 x，遍历 x 时只需要遍历奇数即可。

**分解质因数**
算术基本定理的表述为：任何一个大于 11 的正整数 nn，如果 nn 不是质数，那么 nn 可以唯一地分解成有限个质数的乘积。

$n=p_1^{\alpha_1} \times p_2^{\alpha_2} \times \ldots \times p_k^{\alpha_k}$

其中 $p_1<p_2<\ldots<p_k$ 都是质数，$\alpha_1,\alpha_2,\ldots,\alpha_k$  都是正整数。



[计数质数](https://leetcode-cn.com/problems/count-primes/solution/)

从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数，遍历结束的时候即可知道质数的个数

```java
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ++ans;
                if ((long) i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = false;
                    }
                }
            }
        }
        return ans;
    }
```







### 1.5.5 最大公约数和互质

最大公约数和互质的概念
如果正整数 c 同时是正整数 a 和 b 的约束，即正整数 a 和 b 都是正整数 c 的倍数，则称 c 是 a 和 b 的公约数。正整数 a 和 b 的公约数中的最大值为 a 和 b 的最大公约数，记为 gcd(a,b)。

计算最大公约数常用的算法是欧几里得算法：

当 b=0 时，gcd(a,b)=a；

当 $b \ne 0$时，$\gcd(a,b)=\gcd(b, a \bmod b)$。

如果正整数 a 和 b 的最大公约数是 1，则 a和 b 互质。



裴蜀定理
裴蜀定理的表述为：如果正整数 a 和 b 的最大公约数是 c，则对于任意的整数 x 和 y，ax+by 一定是 c 的倍数，特别地，一定存在整数 x 和 y 使得 ax+by=c。

裴蜀定理的一个重要推论是：正整数 a 和 b 互质地充分必要条件是存在整数 x 和 y 使ax+by=1。

裴蜀定理及其推论可以推广到多个数的情况。

[1250. 检查「好数组」](https://leetcode-cn.com/problems/check-if-it-is-a-good-array/)

一个正整数数组 `nums`，从中任选一些子集，将子集中每一个数乘以一个 **任意整数**，并求出他们的和为 1

这道题实质是裴蜀定理推广到多个数的情况。如果数组 nums 中的元素的最大公约数是 1，则 nums 是「好数组」，否则不是「好数组」

```java
    public boolean isGoodArray(int[] nums) {
        int tmp = nums[0];
        int len = nums.length;
        for(int i = 1; i < len; i++){
            tmp = gcd(tmp, nums[i]);
        }
        return tmp == 1;
    }

    public int gcd(int a, int b){
        if(b == 0){
            return a;
        }
        return gcd(b, a%b);
    }
```



### 1.5.6 排列组合

**组合数学**
组合数学是一门研究离散对象的科学。狭义的组合数学主要研究满足一定条件的组态（也称组合模型）的存在、计数以及构造等方面的问题。

**排列组合**
**加法原理**
如果完成一个任务的方法有 n 类，其中第 i 类方法有 $x_i$种不同的做法，则完成这个任务共有 $x_1+x_2+\ldots+x_n $种不同的做法。

例如，从起点到终点，乘坐公交车有 3 条线路，乘坐地铁有 2 条线路，则一共有 3+2=5 种不同的线路。

**乘法原理**
如果完成一个任务包含 n 个步骤，其中第 i 个步骤有 $x_i$种不同的做法，且这些做法彼此独立，则完成这个任务共有 $x_1 \times x_2 \times \ldots \times x_n $种不同的做法。

例如，从起点经过中转点到终点，从起点到中转点需要乘坐公交车，有 3 条线路，从中转点到终点需要乘坐地铁，有 2 条下路，则一共有 3×2=6 种不同的线路。

**排列数**
从 n 个不同的元素中依次取 m 个元素（m≤n），产生的不同排列的数量为：

$P_n^m=\frac{n!}{(n-m)!}=n \times (n-1) \times \ldots \times (n-m+1)$

其中 n! 表示 n 的阶乘。

**组合数**
从 n 个不同的元素中任取 m 个元素（m≤n），产生的不同组合的数量为：

$C_n^m=\frac{P_n^m}{m!}=\frac{n!}{m!(n-m)!}=\frac{n \times (n-1) \times \ldots \times (n-m+1)}{m \times (m-1) \times \ldots \times 1}$

 

**组合数性质**
组合数的性质较多，此处列举两个重要的性质。

组合数递推公式：$C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$。

二项式定理：$(x+y)^n=\sum_{k=0}^n C_n^k x^k y^{n-k}(x+y)$



[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？
>

```java
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
```





[杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/solution/)

从左上角到右下角的过程中，我们需要移动 m+n-2次，其中有 m-1次向下移动，n-1次向右移动。因此路径的总数，就等于从 m+n-2 次移动中选择 m-1次向下移动的方案数，即组合数：${\Large C}_{m+n-2}^{m-1} = \binom{m+n-2}{m-1} = \frac{(m+n-2)(m+n-3)\cdots n}{(m-1)!} = \frac{(m+n-2)!}{(m-1)!(n-1)!}$

```java
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
```





```java
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        
        for(int i = 0; i < numRows; i++){
            List<Integer> row = new ArrayList<Integer>();
            for(int j = 0; j < i+1; j++){
                if(j == 0 || j == i){
                    row.add(1);
                }else{
                    row.add( list.get(i-1).get(j-1) + list.get(i-1).get(j) );
                }
            }
            list.add(row);

        }
        return list;
```







# 2. 查找

## 2.1 二分查找

### 2.1.1 二分查找两种基本写法的差异
- 写法一

```java
		// 获取最左边位置
       while(l < r){
            int mid = l + (r - l) / 2;
            if(target > nums[mid]){
                l = mid + 1;
            } else {
                r = mid;
            }
        }
```
这种写法里面`mid = l + (r - l) / 2`，其中`l = mid + 1`，`mid`最大值为`r-1`
二分查找里面主要是防止出现死循环，假设更换`l=mid+1`为`l=mid`，当`l = r-1`时，如果此时`mid = r-1`，就会出现`[r-1, r]`的死循环
为了防止出现，则`mid = r-1`时，`l=mid+1` ==>`[r, r]`此时循环就会结束



- 写法二

```java
		// 获取最右边位置
        while(l < r){
            int mid = l + (r - l + 1) / 2;
            if(target < nums[mid]){
                r = mid - 1;
            }else{
                l = mid;
            }
        }
```
假设仍然用写法一里面`mid = l + (r - l) / 2`，`mid`最大值为`r-1`

此时`l=mid`这个不去改变，肯定存在`l = r-1`时，然后带入`mid = l+(r-l)/2 = r-1 + (r-r+1)/2 = r-1`，然后`l = mid = r-1`，此时又出现了`l=r-1`，进入死循环

为了避免这种情况，我们需要改变为`mid = l + (r - l + 1)/2`，这样当`l=r-1`时，`mid=r`，直接结束循环。



### 2.1.2 二分查找找不同位置情况划分

#### 2.1.2.1 找相同的target

- 找最左侧target

`target > nums[mid]`作为条件，则即使`target == nums[mid]`也会`r=mid`来不断的向左移动，直到最左边
```java
        int[] nums = new int[]{3,6,6,6,6,7,11};
        int target = 6;
        int l = 0, r = nums.length-1;

        while(l < r){
            int mid = l+(r-l)/2;
            System.out.println("l: " + l + " mid: " + mid +" r:"+r);
            if(nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }

        System.out.println("target position: " + l);
```

```
l: 0 mid: 3 r:6
l: 0 mid: 1 r:3
l: 0 mid: 0 r:1
target position: 1
```

- 找最右侧target

`target < nums[mid]`作为条件，则即使`target == nums[mid]`也会`l=mid`来不断的向右移动，直到最右边
```java
        int[] nums = new int[]{3,6,6,6,6,7,11};
        int target = 6;
        int l = 0, r = nums.length-1;

        while(l < r){
            int mid = l+(r-l+1)/2;
            System.out.println("l: " + l + " mid: " + mid +" r:"+r);
            if(nums[mid] > target) {
                r = mid - 1;
            } else {
                l = mid;
            }
        }
        System.out.println("target position:" + l);
```
遍历结果：
```
l: 0 mid: 3 r:6
l: 3 mid: 5 r:6
l: 3 mid: 4 r:4
target position:4
```


#### 2.1.2.2 找target插入位置
此时**修改找左侧相同target**的写法一中`r = nums.length`则可以扩大搜索范围，如果大于任何一个数则插入最后
```java
        int[] nums = new int[]{3,6,6,6,6,7,11};
        int target = 12;
        int l = 0, r = nums.length;

        while(l < r){
            int mid = l+(r-l)/2;
            System.out.println("l: " + l + " mid: " + mid +" r:"+r);
            if(nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }

        System.out.println("target position: " + l);
```

```
l: 0 mid: 3 r:7
l: 4 mid: 5 r:7
l: 6 mid: 6 r:7
target position: 7
```

但是需要注意的是这里**不能使用找右侧相同target**的方法去写，会出现溢出的情况，当达到最大`mid = nums.length`，此时就会出现`nums[mid]`报错
	```
l: 0 mid: 4 r:7
l: 4 mid: 6 r:7
l: 6 mid: 7 r:7   // 这里报错
	```



### 2.1.3 二分查找迭代改递归

```java
class Solution {
    public int findMin(int[] nums) {
        return findMin(nums, 0, nums.length-1);
    }

    public int findMin(int[] nums, int l, int r){
        if(l == r){   // 递归终止条件
            return nums[l];
        }

        int mid = l + (r-l)/2;
        if(nums[mid] <= nums[r]){
            return findMin(nums, l, mid);
        }else{
            return findMin(nums, mid+1, r);
        }
    }
}
```









# 3. 排序

## 冒泡排序

```java
    public void bubble(){
        int[] nums = new int[]{6,2,1,3,5,4};
        int len = nums.length;
        boolean isSwap = false;
        for(int i = 0; i < len -1 ; i++){
            isSwap = false;
            for(int j = 0; j < len - 1- i; j++){
                if(nums[j] > nums[j+1]){
                    swap(nums, j, j+1);
                    isSwap = true;
                }
            }
            // 优化：当遍历一遍后没有发生改变则停止遍历
            if(! isSwap){
                break;
            }
        }
        System.out.println(Arrays.toString(nums));
    }

    public void swap(int[] nums, int a, int b){
        nums[a] = nums[a] + nums[b];
        nums[b] = nums[a] - nums[b];
        nums[a] = nums[a] - nums[b];
    }
```









## 选择排序

```java
public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 最后一轮只有一个元素，一定是最大的元素，因此写 i < len - 1
        for (int i = 0; i < len - 1; i++) {
            // 在 [i + 1, len - 1] 区间里选择最小的元素的下标
            int minIndex = i;
            for (int j = i + 1; j < len; j++) {
                if (nums[j] < nums[minIndex]) {
                    minIndex = j;
                }
            }
            swap(nums, minIndex, i);
        }
        return nums;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
```



## 插入排序

基础版本

```java
    public void InsertSort1(){
        int[] nums = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        int n = nums.length;
        for(int i = 1; i < n; i++){
            int j = i, tmp = nums[i];
            while(j > 0 && nums[j-1] > tmp ){
                nums[j] = nums[j-1];
                j--;
            }
            nums[j] = tmp;
        }
        System.out.println(Arrays.toString(nums));

    }

```

在内层循环里都有` j > 0 `这个判断条件，有一种插入排序的写法，先找到整个数组中最小的那个元素，把它交换到数组的第 1 个位置（下标为 0），后面的逻辑就可以去掉 `j > 0`。

使用哨兵后

```java
	public void InsertSort2(){
        int[] nums = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        int n = nums.length;
        // 找最小值
        int minIndex = 0;
        for(int i = 0; i < n; i++){
            if(nums[i] < nums[minIndex]){
                minIndex = i;
            }
        }
        // 将最小值交换到第一个
        swap(nums, 0, minIndex);
        System.out.println(Arrays.toString(nums));

        // 在已有哨兵情况下交换排序
        for(int i = 1; i < n; i++){
            int j = i;
            int tmp = nums[j];
            while(nums[j-1] > tmp){
                nums[j] = nums[j-1];
                j--;
            }
            nums[j] = tmp;
        }
        System.out.println(Arrays.toString(nums));

    }
```







## 归并排序

```java

public class MergeSort {

    public int[] sortArray(int[] nums){
        int n = nums.length;
        // 优化1：使用全局数组，减少内部使用数组不断释放申请操作
        int[] tmp = new int[n];
        
        mergeSort(nums, tmp, 0, n-1);
        return nums;
    }

    public void mergeSort(int[] nums, int[] tmp, int l, int r){
        // 递归终止条件
        if(l == r){
            return;
        }

        // 递归分割
        int mid = l + (r - l) / 2;
        mergeSort(nums, tmp, l, mid);
        mergeSort(nums, tmp, mid+1, r);

        // 优化2：提前剪枝
        if(nums[mid] <= nums[mid+1]){
            return;
        }

        //合并两个数组并使用双指针按顺序排列
        mergeArrays(nums, tmp,  l, mid, r);

    }

    public void mergeArrays(int[] nums, int[] tmp, int l, int mid, int r){
        for(int i = l; i <= r; i++){
            tmp[i] = nums[i];
        }

        int i = l, j = mid + 1;
        for(int k = l; k <= r; k++){
            if(i == mid + 1){
                nums[k] = tmp[j];
                j++;
            }else if(j == r+1){
                nums[k] = tmp[i];
                i++;
            }else if(tmp[i] <= tmp[j]){
                nums[k] = tmp[i];
                i++;
            }else{
                nums[k] = tmp[j];
                j++;
            }
        }
    }

    @Test
    public void test(){
        int[] nums = new int[]{8,6,7,5,4,3,2,1};
        sortArray(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```



## 快速排序

```java

import java.util.Random;

public class QuickSort {
    public void Sort(int[] nums){
        int len = nums.length;
        quickSort(nums, 0, len-1);
        System.out.println(Arrays.toString(nums));
    }

    public void quickSort(int[] nums, int l, int r){
        if(l >= r){
            return;
        }
        int mid = partition(nums, l, r);
        quickSort(nums, l, mid-1);
        quickSort(nums, mid+1, r);
    }

    public int partition(int[] nums, int l, int r){
        int rand = l + new Random().nextInt(r-l+1);
        swap(nums, l, rand);
        int pivot = nums[l];
        int lt = l;
        for(int i = l+1; i <= r; i++ ){
            if(nums[i] < pivot){
                lt++;
                swap(nums, i, lt);
            }
        }
        swap(nums, lt, l);

        return lt;
    }

    public void swap(int[] nums, int a, int b){
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }

    @Test
    public void test(){
        int[] nums = new int[]{4,5,1,6,7,3,2};
        Sort(nums);
    }

}
```



## 堆排序

![初始化堆](https://assets.leetcode-cn.com/solution-static/912_fig2.gif)

![交换元素](https://assets.leetcode-cn.com/solution-static/912_fig3.gif)

将根节点的下标视为 `0`，则完全二叉树有如下性质：

- 对于完全二叉树中的第 `i` 个数，它的左子节点下标：`left = 2i + 1`
- 对于完全二叉树中的第 `i` 个数，它的右子节点下标：`right = left + 1`
- 对于有 `n` 个元素的完全二叉树`(n≥2)`，它的最后一个非叶子结点的下标：`n/2 - 1`





```java
public static void heapSort(int[] arr) {
    // 构建初始大顶堆
    buildMaxHeap(arr);
    for (int i = arr.length - 1; i > 0; i--) {
        // 将最大值交换到数组最后
        swap(arr, 0, i);
        // 调整剩余数组，使其满足大顶堆
        maxHeapify(arr, 0, i);
    }
}
// 构建初始大顶堆
private static void buildMaxHeap(int[] arr) {
    // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        maxHeapify(arr, i, arr.length); // 注意这里是arr.length
    }
}
// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小
private static void maxHeapify(int[] arr, int i, int heapSize) {
    // 左子结点下标
    int l = 2 * i + 1;
    // 右子结点下标
    int r = l + 1;
    // 记录根结点、左子树结点、右子树结点三者中的最大值下标
    int largest = i;
    // 与左子树结点比较
    if (l < heapSize && arr[l] > arr[largest]) {
        largest = l;
    }
    // 与右子树结点比较
    if (r < heapSize && arr[r] > arr[largest]) {
        largest = r;
    }
    if (largest != i) {
        // 将最大值交换为根结点
        swap(arr, i, largest);
        // 再次调整交换数字后的大顶堆
        maxHeapify(arr, largest, heapSize);
    }
}
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```



# 4. 滑动数组

## 4.1固定长度滑动数组

[643. 子数组最大平均数 I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)

>给你一个由 `n` 个元素组成的整数数组 `nums` 和一个整数 `k` 。
>
>请你找出 **和最大** 且 **长度为 `k`** 的**连续子数组**
>
>nums = [1,12,-5,-6,50,3], k = 4
>
>12, -5, -6, 50

![](https://assets.leetcode-cn.com/solution-static/643/1.png)

![](https://assets.leetcode-cn.com/solution-static/643/2.png)

固定滑动数组特征：每次滑动，只少了上一个数组的最左侧，多了这个数组的最右侧，中间的不变

所以先求出第一个数组`sum`

然后再不断向后移动修改，设`i`初始为`k`,则`sum = sum - nums[i-k] + nums[i]`

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        int n = nums.length;
        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }
        int maxSum = sum;
        for (int i = k; i < n; i++) {
            sum = sum - nums[i - k] + nums[i];
            maxSum = Math.max(maxSum, sum);
        }
        return 1.0 * maxSum / k;
    }
}
```

#### 

#### [1052. 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)

#### [1423. 可获得的最大点数](https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/)

题目：几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。你的点数就是你拿到手中的所有卡牌的点数之和。

解法：每次只能从边界取一值，那么可以转换为在数组内部取一个固定大小的

#### [1658. 将 x 减到 0 的最小操作数](https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/)

#### [1456. 定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)



## 4.2不定长交替滑动数组

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

> 例题1：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
>
> 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。
>
> 示例 1：
>
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
> 示例 2：
>
> 输入：s = "a", t = "a"
> 输出："a"

方法：滑动窗口
一开始的时候，`left` 和 `right` 都位于下标 `0` 的位置。`right` 向右移动，直至包含 `T` 的所有字母。由于我们要求的是最小子串，因此，以 `left` 开头的子串 `[left..right + 1]、 [left..right + 2]、……、 [left..len - 1]` 一定不符合要求，因此这些区间可以不用判断；
然后考虑 `left` 如何移动。此时 `left` 不能向左移动，向左移动只能让子串更长，我们要求最小子串，因此 `left` 只能右移，移到恰恰好 `[left..right]` 区间里面的字符不包含 `T` 所有字母的最小子串；
然后 `right` 继续向右移动，直到包含 `T` 所有字母的最小子串。
重复这样的过程，直到 `right` 到达 `S` 的末尾。怎么样，这个思想是不是和第 3 题是一样的，尺取法。

```java
public class Solution {

    public String minWindow(String s, String t) {
        int[] window = new int[128];
        int[] pattern = new int[128];

        final int A = 'A';

        for (Character c : t.toCharArray()) {
            pattern[c - A]++;
        }
        int distance = 0;

        for (int i = 0; i < 128; i++) {
            if (pattern[i] > 0) {
                distance++;
            }
        }

        int sLen = s.length();
        int start = 0;
        int left = 0;
        int right = 0;
        int match = 0;
        int minLen = sLen + 1;

        while (right < sLen) {
            Character curChar = s.charAt(right);
            if (pattern[curChar - A] > 0) {
                window[curChar - A]++;

                if (window[curChar - A] == pattern[curChar - A]) {
                    match++;
                }
            }

            right++;

            while (match == distance) {
                if (right - left < minLen) {
                    start = left;
                    minLen = right - left;
                }

                // 考虑左边界向右边走
                Character leftChar = s.charAt(left);
                if (pattern[leftChar - A] > 0) {
                    window[leftChar - A]--;

                    if (window[leftChar - A] < pattern[leftChar - A]) {
                        match--;
                    }
                }
                left++;
            }
        }
        return minLen == sLen + 1 ? "" : s.substring(start, start + minLen);
    }
}
```



-----

**「滑动窗口」算法有下面的特点：**

`right` 先向右移动，移到不能再移动的时候，`left` 再向右移动；
`right` 右移使得滑动窗口边长，刚好满足条件，`left` 右移使得滑动窗口变短到刚好不满足条件，然后 `right` 变长刚好满足条件，如此循环下去，直到 `right` 到达末尾。这里的条件是指：`[left, right)` 包含 `T` 所有字母。
那么如何判断区间 `[left, right]` 内包含 `T` 所有字母呢？由于我们并不关心字母的顺序，因此我们采用的是对比频数数组的方式。

先对 `T` 做频数统计，然后设置一个变量 `distance` 表示 `T` 中一共有多少个不同的字母；
`left` 和 `right` 在动的时候，只对 `T` 中出现的字母做统计；
`right` 移动的时候，频数增加，加到刚刚好和 T 对应字母相等的时候，`distance - 1`，表示滑动窗口内的字母种类与 `T` 的差距减少了 `1`，当这个差距为 `0` 的时候，滑动窗口内包含 T 所有字母的最小子串。此时考虑移动 `left`；
`left` 移动的时候，做减法，减少到刚刚好比 `T` 中对应字符个数少 `1` 的时候，就说明「平衡」被打破，此时应该 `right` 继续向右移动。

#### [424. 替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

> 例题：替换后的最长重复字符
> 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
>
> 注意：字符串长度 和 k 不会超过 10^410 
> 4
>  。
>
> 示例 1：
>
>
> 输入：s = "ABAB", k = 2
> 输出：4
> 解释：用两个'A'替换为两个'B',反之亦然。
> 示例 2：
>
> 输入：s = "AABABBA", k = 1
> 输出：4
> 解释：
> 将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
> 子串 "BBBB" 有最长重复字母, 答案为 4。

```java
public class Solution {

    public int characterReplacement(String s, int k) {
        int len = s.length();
        if (len < 2) {
            return len;
        }

        char[] charArray = s.toCharArray();
        int left = 0;
        int right = 0;

        int res = 0;
        int maxCount = 0;
        int[] freq = new int[26];
        // [left, right) 内最多替换 k 个字符可以得到只有一种字符的子串
        while (right < len){
            freq[charArray[right] - 'A']++;
            // 在这里维护 maxCount，因为每一次右边界读入一个字符，字符频数增加，才会使得 maxCount 增加
            maxCount = Math.max(maxCount, freq[charArray[right] - 'A']);
            right++;

            if (right - left > maxCount + k){
              	// 说明此时 k 不够用
                // 把其它不是最多出现的字符替换以后，都不能填满这个滑动的窗口，这个时候须要考虑左边界向右移动
                // 移出滑动窗口的时候，频数数组须要相应地做减法
                freq[charArray[left] - 'A']--;
                left++;
            }
            res = Math.max(res, right - left);
        }
        return res;
    }
}
```



**滑动窗口模板总结**

```java
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        int len = s.length();  // 一般给定数组或字符串
        int[] counts = new int[128]; // 用于统计遍历过的字符个数，也可以用HashMap和HashSet
        int l = 0, r = 0; // 左右指针
        int maxlen = 0; // 有时求最大长度，有时求最短长度minlen = len+1
        int size = 0; // 具体需求下的不同的辅助变量，有的为subsum, sum
        
        // 右指针移动至边界
        while( r < len ){
            // 对右指针所指变量统计分析
            int curRight = s.charAt(r) - ' '; 
            counts[curRight]++;
            if(counts[curRight] == 1){
                size++;
            }
            
            // 当不满足需求时，开始移动左指针，改变滑动窗口大小，直至满足需求
            while(size > k){
                int curLeft = s.charAt(l) - ' ';
                counts[curLeft]--;
                if(counts[curLeft] == 0){
                    size--;
                }
                l++; // 移动左指针
            }
            
            // 比较当前子串长度和最大或最小子串长度
            maxlen = Math.max(maxlen, r-l+1);
            // 右指针移动
            r++;
        }
        return maxlen;
    }
```

[76.最小覆盖子串（困难）](https://leetcode-cn.com/problems/minimum-window-substring)

[567.字符串的排列（中等）](https://leetcode-cn.com/problems/permutation-in-string)

[438.找到字符串中所有字母异位词（中等）](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)

[3.无重复字符的最长子串（中等）](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)



## 4.3 滑动窗口里计数问题

#### [159. 至多包含两个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/)

#### [340. 至多包含 K 个不同字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/)



## 4.4使用数据结构维护窗口性质





## 4.5双指针：相向交替移动的两个变量









# 5.链表

## 5.0 时间复杂度

![](img/数组队列栈链表时间复杂度.png)

## 5.1设计单链表

[707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)

> 在链表类中实现这些功能：
>
> get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
> addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
> addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
> addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
> deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```java
public class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}

class MyLinkedList {
  int size;
  ListNode head;  // sentinel node as pseudo-head
  public MyLinkedList() {
    size = 0;
    head = new ListNode(0);
  }

  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
  public int get(int index) {
    // if index is invalid
    if (index < 0 || index >= size) return -1;

    ListNode curr = head;
    // index steps needed 
    // to move from sentinel node to wanted index
    for(int i = 0; i < index + 1; ++i) curr = curr.next;
    return curr.val;
  }

  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
  public void addAtHead(int val) {
    addAtIndex(0, val);
  }

  /** Append a node of value val to the last element of the linked list. */
  public void addAtTail(int val) {
    addAtIndex(size, val);
  }

  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
  public void addAtIndex(int index, int val) {
    // If index is greater than the length, 
    // the node will not be inserted.
    if (index > size) return;

    // [so weird] If index is negative, 
    // the node will be inserted at the head of the list.
    if (index < 0) index = 0;

    ++size;
    // find predecessor of the node to be added
    ListNode pred = head;
    for(int i = 0; i < index; ++i) pred = pred.next;

    // node to be added
    ListNode toAdd = new ListNode(val);
    // insertion itself
    toAdd.next = pred.next;
    pred.next = toAdd;
  }

  /** Delete the index-th node in the linked list, if the index is valid. */
  public void deleteAtIndex(int index) {
    // if the index is invalid, do nothing
    if (index < 0 || index >= size) return;

    size--;
    // find predecessor of the node to be deleted
    ListNode pred = head;
    for(int i = 0; i < index; ++i) pred = pred.next;

    // delete pred.next 
    pred.next = pred.next.next;
  }
}
```











## 5.2设计双向链表

![](img/double_LinkNode.jpg)

```java
public class ListNode {
  int val;
  ListNode next;
  ListNode prev;
  ListNode(int x) { val = x; }
}

class MyLinkedList {
  int size;
  // sentinel nodes as pseudo-head and pseudo-tail
  ListNode head, tail;
  public MyLinkedList() {
    size = 0;
    head = new ListNode(0);
    tail = new ListNode(0);
    head.next = tail;
    tail.prev = head;
  }

  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
  public int get(int index) {
    // if index is invalid
    if (index < 0 || index >= size) return -1;

    // choose the fastest way: to move from the head
    // or to move from the tail
    ListNode curr = head;
    if (index + 1 < size - index)
      for(int i = 0; i < index + 1; ++i) curr = curr.next;
    else {
      curr = tail;
      for(int i = 0; i < size - index; ++i) curr = curr.prev;
    }

    return curr.val;
  }

  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
  public void addAtHead(int val) {
    ListNode pred = head, succ = head.next;

    ++size;
    ListNode toAdd = new ListNode(val);
    toAdd.prev = pred;
    toAdd.next = succ;
    pred.next = toAdd;
    succ.prev = toAdd;
  }

  /** Append a node of value val to the last element of the linked list. */
  public void addAtTail(int val) {
    ListNode succ = tail, pred = tail.prev;

    ++size;
    ListNode toAdd = new ListNode(val);
    toAdd.prev = pred;
    toAdd.next = succ;
    pred.next = toAdd;
    succ.prev = toAdd;
  }

  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
  public void addAtIndex(int index, int val) {
    // If index is greater than the length, 
    // the node will not be inserted.
    if (index > size) return;

    // [so weird] If index is negative, 
    // the node will be inserted at the head of the list.
    if (index < 0) index = 0;

    // find predecessor and successor of the node to be added
    ListNode pred, succ;
    if (index < size - index) {
      pred = head;
      for(int i = 0; i < index; ++i) pred = pred.next;
      succ = pred.next;
    }
    else {
      succ = tail;
      for (int i = 0; i < size - index; ++i) succ = succ.prev;
      pred = succ.prev;
    }

    // insertion itself
    ++size;
    ListNode toAdd = new ListNode(val);
    toAdd.prev = pred;
    toAdd.next = succ;
    pred.next = toAdd;
    succ.prev = toAdd;
  }

  /** Delete the index-th node in the linked list, if the index is valid. */
  public void deleteAtIndex(int index) {
    // if the index is invalid, do nothing
    if (index < 0 || index >= size) return;

    // find predecessor and successor of the node to be deleted
    ListNode pred, succ;
    if (index < size - index) {
      pred = head;
      for(int i = 0; i < index; ++i) pred = pred.next;
      succ = pred.next.next;
    }
    else {
      succ = tail;
      for (int i = 0; i < size - index - 1; ++i) succ = succ.prev;
      pred = succ.prev.prev;
    }

    // delete pred.next 
    --size;
    pred.next = succ;
    succ.prev = pred;
  }
}
```



## 5.3 链表中的双指针

### 5.3.1快慢指针

慢指针每次移动一步`slow = slow.next`

快指针每次移动两步`fast = fast.next.next`

需要注意的是空指针异常问题，所以要提前判断当前所指是否为`null`，以及考虑下一个`fast.next == null`，`fast`和`slow`指针同时移动，一般只需要判断`fast`指针的`null`异常，因为`slow`在其后相对安全

**基本模板**

```java
// Initialize slow & fast pointers
ListNode slow = head;
ListNode fast = head;
/**
 * Change this condition to fit specific problem.
 * Attention: remember to avoid null-pointer error
 **/
while (slow != null && fast != null && fast.next != null) {
    slow = slow.next;           // move slow pointer one step each time
    fast = fast.next.next;      // move fast pointer two steps each time
    if (slow == fast) {         // change this condition to fit specific problem
        return true;
    }
}
return false;   // change return value to fit specific problem
```



#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

题目：给定一个链表，**判断**链表中是否有环

解法：快慢指针：设置两个快慢指针，如果存在循环则两个指针一定会相遇

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

题目：给定一个链表，**返回链表开始入环的第一个节点**。 如果链表无环，则返回 `null`。

解法：当快慢指针相遇后，置`fast = head`，然后两个指针同时移动，**每次只移动一步**，最后相遇的节点为入环节点。

#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。

解法：快指针是慢指针的两倍速度，则快指针到达终点时，慢指针也到达了中点

### 5.3.2 固定窗口指针

设置两个移动速度相同的指针，两个指针的位置相差`n`

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

题目：给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

解法：链表headA 和 headB 的长度分别是 m 和 n。假设链表**headA 的不相交部分有 a** 个节点，链表 **headB 的不相交部分有 b** 个节点，两个链表**相交的部分有 c** 个节点，则有 a+c=m，b+c=n。

如果 a=b，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；

如果 a != b，则指针 pA 会遍历完链表 headA，指针pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针 pA 移到链表headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 **pA 移动了 a+c+b 次**、指针 **pB 移动了 b+c+a 次**之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。



## 5.4链表经典题

对链表修改

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

#### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

#### [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

对链表合并

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)



# 深度优先遍历

#### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/

递归表示

```java
public static void preOrderRecur(TreeNode head) {
    if (head == null) {
        return;
    }
    System.out.print(head.value + " ");
    preOrderRecur(head.left);
    preOrderRecur(head.right);
}
```

非递归通过栈表示

```java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        if(root == null){
            return list;
        }
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while( !stack.isEmpty() ){
            TreeNode cur = stack.pop();
            list.add(cur.val);
            if(cur.right != null){
                stack.push(cur.right);
            }
            if(cur.left != null){
                stack.push(cur.left);
            }
        }
        return list;
```



#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```java
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode cur = root;
        while(! stack.isEmpty() || cur != null){
            while(cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            list.add(cur.val);
            cur = cur.right;
        }
```

#### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```java
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while( !stack.isEmpty()){
            TreeNode cur = stack.pop();
            list.add(0, cur.val);
            if(cur.left != null){
                stack.push(cur.left);
            }
            if(cur.right != null){
                stack.push(cur.right);
            }
        }
```



#### [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

递归

```java
    public List<Integer> preorder(Node root) {
        List<Integer> list = new ArrayList<>();
        dfs(root, list);
        return list;
    }

    public void dfs(Node root, List<Integer> list){
        if(root == null){
            return;
        }
        list.add(root.val);
        int len = root.children.size();
        for(int i = 0; i < len; i++){
            dfs(root.children.get(i), list);
        }
    }
```

迭代方法

```java
    public List<Integer> preorder(Node root) {
        List<Integer> list = new ArrayList<Integer>();
        if(root == null){
            return list;
        }

        Deque<Node> stack = new ArrayDeque<>();
        stack.push(root);
        while( !stack.isEmpty()){
            Node cur = stack.pop();
            list.add(cur.val);
            int len = cur.children.size();
            for(int i = len-1; i >= 0; i--){
                stack.push(cur.children.get(i));
            }
        }
        return list;
    }
```





#### [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

#### [1008. 前序遍历构造二叉搜索树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)



# 广度优先遍历

使用队列暂存节点`    Queue<TreeNode> queue = new LinkedList<>()`

或者通过双端队列`Deque<TreeNode> queue = new ArrayDeque<>()`



#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        if(root == null){
            return ans;
        }
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.addLast(root);

        while(!queue.isEmpty()){
            // 需要将队列长度存下，对整个队列遍历一遍
            int size= queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0; i < size; i++){
                TreeNode cur = queue.pollFirst();
                list.add(cur.val);
                if(cur.left != null){
                    queue.addLast(cur.left);
                }
                if(cur.right != null){
                    queue.addLast(cur.right);
                }
            }
            ans.add(list);
        }
        return ans;
    }
```





#### [323. 无向图中连通分量的数目](https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/)

> 给定编号从 0 到 n-1 的 n 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。
>
> 示例 1:
>
> 输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]
>
>      0          3
>      |          |
>      1 --- 2    4 
>
> 输出: 2
>

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Solution {

    public int countComponents(int n, int[][] edges) {
        // 第 1 步：构建图
        List<Integer>[] adj = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<>();
        }
        // 无向图，所以需要添加双向引用
        for (int[] edge : edges) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }

        // 第 2 步：开始广度优先遍历
        int res = 0;
        boolean[] visited = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                bfs(adj, i, visited);
                res++;
            }
        }
        return res;
    }

    /**
     * @param adj     邻接表
     * @param u       从 u 这个顶点开始广度优先遍历
     * @param visited 全局使用的 visited 布尔数组
     */
    private void bfs(List<Integer>[] adj, int u, boolean[] visited) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(u);
        visited[u] = true;

        while (!queue.isEmpty()) {
            Integer front = queue.poll();
            // 获得队首结点的所有后继结点
            List<Integer> successors = adj[front];
            for (int successor : successors) {
                if (!visited[successor]) {
                    queue.offer(successor);
                    // 特别注意：在加入队列以后一定要将该结点标记为访问，否则会出现结果重复入队的情况
                    visited[successor] = true;
                }
            }
        }
    }
}
```

#### [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)
