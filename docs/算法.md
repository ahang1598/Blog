> 本文参考
>
> [力扣 (LeetCode)](https://leetcode-cn.com/leetbook/read/bit-manipulation-and-math) 

# 1. 位运算和数学

## 1.1 进制

### 1.1.1 概念

十进制的 123.45 可以写成如下形式：

$123.45 = 1 \times 10^2 + 2 \times 10^1 + 3 \times 10^0 + 4 \times 10^{-1} + 5 \times 10^{-2}$

八进制的 720.5 可以写成如下形式：

$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1}$



### 1.1.2 进制转换

- **转成十进制**：八进制数 $720.5_{(8)}$**转成十进制**：

$720.5_{(8)} = 7 \times 8^2 + 2 \times 8^1 + 0 \times 8^0 + 5 \times 8^{-1} = 464.625$



- **整数转成非十进制**：十进制数 50 **转成二进制**：
  50÷2=25 余 0
  25÷2=12 余 1
  12÷2=6 余 0
  6÷2=3 余 0
  3÷2=1 余 1
  1÷2=0 余 1

**反向遍历**每次的余数，依次是 1,1,0,0,1,0，因此十进制数 50 转成二进制数是 $110010_{(2)}$



- **小数转成非十进制**：十进制数 **0.6875 转成二进制**：
  0.6875×2=1.375 整 1
  0.375×2=0.75 整 0
  0.75×2=1.5 整 1
  0.5×2=1 整 1

**正序遍历**每次的整数部分，依次是 1,0,1,1，因此十进制数 0.6875 转成二进制数是 $0.1011_{(2)}$



**其他进制间的转换**
如果需要在两个不同的非十进制之间转换，常规的思路是**先转成十进制数**，**再转成目标进制数**。在一些特殊情况下，也可以不经过十进制，直接进行转换。

例如，将二进制数转成八进制数或十六进制数，以及将八进制数或十六进制数转成二进制数，都不需要经过十进制。**一位八进制数可以表示成三位二进制数**，**一位十六进制数可以表示成四位二进制数**。

- **二转八**：对于二进制数 $101110010_{(2)}$  ，按照三位一组进行分组，可以得到 101|110|010，因此转成八进制数是 $562_{(8)}$

- **二转十六**：按照四位一组进行分组，可以得到1∣0111∣0010，转成十六进制数是 $172_{(16)}$



例题：[七进制](https://leetcode-cn.com/problems/base-7/solution/), 





## 1.2 整数表示

### 1.2.1 有符号和无符号整数

- 有符号整数：最高位表示符号，最高位0表示整数，1表示负数。
  - 以 1 字节为例，1 字节包含8为二进制。最高位为0时，1 字节取值范围0~127（$2^7 -1$）。最高位为 1 时，1 字节的取值范围 -128 ($- 2^7$)  ~  -1。则 1 字节取值范围 -128 ~ 127  （$- 2^7 \sim 2^7-1$）
- 无符号整数：虽有位表示数字大小
  - 数值范围：0 ~ 255 ($2^8 - 1$)

对于 k 位整数，有符号整数的取值范围是 $-2^{k-1}$ 到 $2^{k-1} - 1$，无符号整数的取值范围是 0 到 $2^k-1$。



### 1.2.2 原码
原码是机器数的符号位加上机器数的真值的绝对值，最高位是符号位，其余位表示数值。

以 8 位二进制数为例。

- +10 的原码是 00001010，

- -10 的原码是 10001010。

8位二进制数的原码表示的最大值是 01111111，即十进制的 +127，最小值是 11111111，即十进制的 -127，因此 8 位二进制数的原码表示的取值范围是 -127 到 +127。

### 1.2.3 反码
反码在原码的基础上得到。

0 和**正数的反码与原码相同**，**负数**的反码是**将原码的除了符号位之外的每一位取反**，取反即为将 0 变成 1 或将 1 变成 0。

以 8 位二进制数为例。

- +10 的原码是 00001010，反码是 000010100；

- -10 的原码是 10001010，反码是 11110101。

### 1.2.4 补码

补码在反码的基础上得到。

**0** 和**正数的补码与原码、反码相同**，**负数**的补码是在**反码的基础上加 1** 得到。

以 8 位二进制数为例。

- +10 的原码是 00001010，反码是 00001010，补码是 00001010；

- -10 的原码是 10001010，反码是 11110101，补码是 111101101。



### 1.2.5 原码反码补码存在原因

但是**原码存在两个问题**：

- 同时存在 +0（即符号位和其余位都是 0）和 -0（即符号位是 1，其余位都是 0）的表示，虽然可以认为 **+0 和 -0 是同一个数**，但是 0 带符号是没有意义的，而且会导致有**两个不同的原码都对应 0**；

- 用原码进行**减法**运算，会导致**错误**的结果。

**反码的引入**，**解决了原码的减法运算结果错误**的问题，但是仍然没有解决同时存在 +0 和 −0 的问题。

**补码的引入**则**同时解决了减法运算错误**和**同时存在 +0 和 -0 的问题**，**而且可以多表示一个最小值**。

- 在补码表示法中，不存在 -0 的情况。以 8 位二进制数为例，0 的补码是 00000000，10000000 表示的是 −128，
- −128 没有原码和反码的表示（8 位二进制数的原码和反码能表示的最小值是 -127）。由此可见，补码不仅解决了原码和反码的问题，还可以**多表示一个最小值-128**。

由于补码具有上述优点，因此**计算机采用补码进行运算**



## 1.3 位运算概述

计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。

位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。上述位运算中，只有取反是一元运算，其余的都是二元运算。

**与、或、异或和取反**
与运算的符号是 \&，运算规则是：对于每个二进制位，当两个数对应的位都为 1 时，结果才为 1，否则结果为 0。
0 & 0=0
0 & 1=0
1 & 0=0
1 & 1=1

或运算的符号是 ∣，运算规则是：对于每个二进制位，当两个数对应的位都为 0 时，结果才为 0，否则结果为 1。
0 ∣ 0=0
0 ∣ 1=1
1 ∣ 0=1
1 ∣ 1=1

异或运算的符号是 ⊕（在代码中用 ∧ 表示异或），运算规则是：对于每个二进制位，当两个数对应的位相同时，结果为 0，否则结果为 1。
0⊕0=0
0⊕1=1
1⊕0=1
1⊕1=0

取反运算的符号是 ∼，运算规则是：对一个数的每个二进制位进行取反操作，0 变成 1，1 变成 0。
∼0=1
∼1=0

以下例子显示上述四种位运算符的运算结果，参与运算的数字都采用有符号的 8 位二进制表示。

46 的二进制表示是 00101110，51 的二进制表示是 00110011。考虑以下位运算的结果。

46 & 51 的结果是 34，对应的二进制表示是 00100010。

46 ∣ 51 的结果是 63，对应的二进制表示是 00111111。

46⊕51 的结果是 29，对应的二进制表示是 00011101。

∼46 的结果是 −47，对应的二进制表示是 11010001。

∼51 的结果是 −52，对应的二进制表示是 11001100。

### 1.3.1 移位运算

移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。

左移运算的符号是 <<。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。

右移运算的符号是 >>。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：

算术右移时，高位补最高位；

逻辑右移时，高位补 0。

以下例子显示移位运算的运算结果，参与运算的数字都采用有符号的 88 位二进制表示。

29 的二进制表示是 00011101。29 左移 2 位的结果是 116，对应的二进制表示是 01110100；29 左移 3 位的结果是 −24，对应的二进制表示是 11101000。

50 的二进制表示是 00110010。50 右移 1 位的结果是 25，对应的二进制表示是 00011001；50 右移 2 位的结果是 12，对应的二进制表示是 00001100。对于 0 和正数，算术右移和逻辑右移的结果是相同的。

-50 的二进制表示是 11001110。-50 算术右移 2 位的结果是 −13，对应的二进制表示是 11110011；−50 逻辑右移 2 位的结果是 51，对应的二进制表示是 00110011。

右移运算中的算术移位和逻辑移位是不同的，计算机内部的右移运算采取的是哪一种呢？

对于 C/C++ 而言，数据类型包含有符号类型和无符号类型，其中有符号类型使用关键字 signed 声明，无符号类型使用关键字 unsigned 声明，两个关键字都不使用时，默认是有符号类型。对于有符号类型，右移运算为算术右移；对于无符号类型，右移运算为逻辑右移。

对于 Java 而言，不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。在 Java 中，算术右移的符号是 >>，逻辑右移的符号是 >>>。

### 1.3.2 移位运算与乘除法的关系

观察上面的例子可以看到，移位运算与乘除法有密切的关联性。由于计算机的底层的一切运算都是基于位运算实现的，因此使用移位运算实现乘除法的效率显著高于直接乘除法的效率。

左移运算对应乘法运算。将一个数左移 k 位，等价于将这个数乘以 $2^k$
 。例如，29 左移 2 位的结果是 116，等价于 29×4。当乘数不是 2 的整数次幂时，可以将乘数拆成若干项 2 的整数次幂之和，例如，a×6 等价于 (a<<2)+(a<<1)。对于任意整数，乘法运算都可以用左移运算实现，但是需要注意溢出的情况，例如在 8 位二进制表示下，29 左移 3 位就会出现溢出。

算术右移运算对应除法运算。将一个数右移 k 位，相当于将这个数除以 $2^k$  。例如，50 右移 2 位的结果是 12，等价于 50/4，结果向下取整。

从程序实现的角度，考虑程序中的整数除法，是否可以说，将一个数（算术）右移 k 位，和将这个数除以 $2^k$等价？对于 0 和正数，上述说法是成立的，整数除法是向 0 取整，右移运算是向下取整，也是向 0 取整。但是对于负数，上述说法就不成立了，整数除法是向 0 取整，右移运算是向下取整，两者就不相同了。例如，(−50)>>2 的结果是 -13，而 (−50)/4 的结果是 −12，两者是不相等的。

因此，将一个数（算术）右移 k 位，和将这个数除以 $2^k$ 是不等价的。



### 1.3.3 位运算的性质

位运算的性质有很多，此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。

幂等律：a & a=a，a ∣ a=a（注意异或不满足幂等律）；

交换律：a & b=b & a，a ∣ b=b ∣ a，a⊕b=b⊕a；

结合律：(a & b) & c=a & (b & c)，(a ∣ b) ∣ c=a ∣ (b ∣ c)，(a⊕b)⊕c=a⊕(b⊕c)；

分配律：(a & b) ∣ c=(a ∣ c) & (b ∣ c)，(a ∣ b) & c=(a & c) ∣ (b & c)，(a⊕b) & c=(a & c)⊕(b & c)；

德·摩根律：∼(a & b)=(∼a) ∣ (∼b)，∼(a ∣ b)=(∼a) & (∼b)；

取反运算性质：−1=∼0,  −a=∼(a−1)；

与运算性质：a & 0=0，a & (−1)=a，a & (∼a)=0；

或运算性质：a ∣ 0=a，a ∣ (∼a)=−1；

异或运算性质：a⊕0=a，a⊕a=0；

其他性质：

a & (a−1) 的结果为将 a 的二进制表示的最后一个 1 变成 0；

a & (−a)（与 a & (∼(a−1)) 等价）的结果为只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0。

利用上述性质，可以巧妙地解决很多位运算的题目。



## 1.4 例题及常用解法

### 1.4.1 取出二进制数下几个位

`num & 0x1`通过数字`&`一个所需位为1，其余位为0的二进制后得到所需的位

取`1`位用`0x1`,取`2`位用`0x3`,取`3`位用`0x7`,取`4`位用`0xf`

所有的取的位都是最低几位，取高位需要用`num >>> i`将数值逻辑右移`i`位后再取



[数字转十六进制](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/)

```java
int num = 30;
for (int i = 7; i >= 0; i--) {
    int val = (num >> (4 * i)) & 0xf; // 从最高位开始，每四位取出一次转化为16进制
    if (sb.length() > 0 || val > 0) {
        char digit = hexChar(val);
        sb.append(digit);
    }
}
```

[二进制数中位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/solution/)

```java
	public int hammingWeight(int n) {
        int count = 0;
        for (int i = 0; i < 32; i++) {
            count += (n >> i) & 1;
        }
        return count;
    }
```

[颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/solution/)

解法一：逐位颠倒

```java
    public int reverseBits(int n) {
        int reversed = 0, power = 31;
        while (n != 0) {
            reversed += (n & 1) << power; // 逐位颠倒，求出每一位并左移相应位置，再相加
            n >>>= 1;
            power--;
        }
        return reversed;
    }
```

解法二：每一行分别将 n 分成 16 位、8 位、4 位、2 位、1 位的块，即把每个块分成两个较小的块，并将分成的两个较小的块颠倒。

`n & 0xff00ff00`留下 n 的8~15, 24~31位

```java
    public int reverseBits(int n) {
        n = (n >>> 16) | (n << 16); // 对半左右颠倒
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8); // 8位划分左右颠倒
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
        return n;
    }
```



[区间内所有数字 按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/)

本质上：找出两个二进制相同前缀

```java
    public int rangeBitwiseAnd(int m, int n) {
        int shift = 0;
        // 找到公共前缀
        while (m < n) {
            m >>= 1;
            n >>= 1;
            ++shift;
        }
        return m << shift;
    }
```



### 1.4.2 二进制的`num`第 `i` 位取反

`num` 异或 `i`位为`1`其余位为`0`的值，

此时其余位与`0`异或不变，第`i`位于`1`异或取反

​    1101

⊕ 0100

-------

​     1001

```java
 num ^ (1 << i-1) 
```



### 1.4.3 a & (a−1) 

a & (a−1) 的结果为将 a 的二进制表示的最后一个 1 变成 0；

[二进制数中位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/solution/)

```java
	public int hammingWeight(int n) {
        int count = 0;
        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
    }
```

[区间内所有数字 按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/)

```java
    public int rangeBitwiseAnd(int m, int n) {
        while (m < n) {
            // 抹去最右边的 1
            n = n & (n - 1);
        }
        return n;
    }
```







### 1.4.4 a⊕0=a，a⊕a=0

异或运算性质：a⊕0=a，a⊕a=0；

[只出现一次的数字](https://leetcode-cn.com/problems/single-number/solution/)

除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素

```java
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int e:nums){
            ans ^= e;
        }
        return ans;
    }
```

### 1.4.5 a & (−a)

a & (−a)（与 a & (∼(a−1)) 等价）

结果为只保留 a 的二进制表示的最后一个 1，其余的 1 都变成 0。

a      00001010

& -a 11110110

​        00000010 只保留了最后一位1

[只出现一次的数字（三）](https://leetcode-cn.com/problems/single-number-iii)

恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素

```
[1,2,1,3,2,5]  
不同两个[3,5]
```

```java
    public int[] singleNumber(int[] nums) {
        int mask = 0;
        for(int e: nums){  // 1. 筛出所有重复元素
            mask ^= e;
        }
        mask &= (-mask);  // 2. 找出两个不同数异或后结果中为1的位，其余位都为0
        // 两个数异或后为1说明，两个数该位置分别为0，1，根据这个区分出两个数

        int[] ans = new int[2];
        for(int e: nums){
            // 当该位为1与所有数与，得出结果为0的，则该位为0的所有数归一类，这一类里面包含出现一次的一个元素 和 成对出现的所有该位为0的数，这些数成对出现异或后则为0，则筛出的数为只出现一次的数
            // 得出结果为1的，则该位为1的所有数归一类
            if( (mask & e) == 0 ){
                ans[0] ^= e;
            }else{
                ans[1] ^= e;
            }
        }
        return ans;
    }
```





### 1.4.6 数字转化为字符

0 --> '0'

10 --> 'a'

```java
    public char hexChar(int num) {
        if (num < 10) {
            return (char) (num + '0');
        } else {
            return (char) (num - 10 + 'a');
        }
    }
```



### 1.4.7 两数求和用位运算

[两数求和用位运算](https://leetcode-cn.com/problems/sum-of-two-integers/solution/)

```java
    public int getSum(int a, int b) {
        while(a != 0){
            int tmp = a ^ b;
            a = (a & b) << 1;
            b = tmp;
        }
        return b;
    }
```





## 1.4 状态压缩

### 1.4.1 状态压缩定义

状态压缩，顾名思义就是将多个值的状态压缩成一个数字。具体而言，如果有 n 个值，每个值有 2 种可能的状态，则状态总数有 $2^n$ 个，可以用一个 n位二进制数记录全部 n 个状态的取值。

例如，一共有 n 个物品，每个物品分别对应一个值，即该物品是拿还是不拿，可以用一个 n 位二进制数表示每个物品的值。当 n=5 时，假设二进制数从最低位到最高位依次表示第 1 个物品到第 5 个物品是拿还是不拿，1 表示拿，0 表示不拿，则 $01011_{(2)}$

  表示拿了第 1 个、第 2 个和第 4 个物品，不拿第 3 个和第 5 个物品。

### 1.4.2 状态压缩的适用场景

如果每个值都有 2 种状态，n 个值对应的状态总数就是 $2^n$，因此只有当 n 较小时，才能适用状态压缩。一般而言，当 n≤20 时，可以考虑状态压缩。

### 1.4.3 状态压缩动态规划

虽然状态压缩的适用场景是数据规模小的情况，但是如果使用回溯等暴力方法求解，仍然可能导致时间复杂度过高，例如对同一种状态重复求解，结果超出时间限制。因此，状态压缩常用于动态规划，使用动态规划就可以避免重复计算的情况。

使用到状态压缩的动态规划称为状态压缩动态规划，是动态规划中最难的一类问题。

动态规划的三个要素是：状态表示、状态转移方程和边界情况，其中，状态表示和状态转移方程是很多动态规划问题的难点，对于状态压缩动态规划，需要使用状态压缩的方式进行状态表示，因此进一步增加了问题的难度。

使用状态压缩动态规划求解时，需要充分考虑状态应该如何表示以及状态之间的关联，得到合适的状态表示和状态转移方程。

## 1.5 数学

### 1.5.1 幂运算

实现 [pow(x, n)](https://leetcode-cn.com/problems/powx-n/solution/)

解法一：递归

```java
    public double myPow(double x, int n) {
        if(n >= 0){
            return pow(x, n);
        }else{
            if(n == -2147483648){
                return  (1/x) * ( 1/ pow(x, -(n+1) ) );
            }
            return 1.0 / pow(x, -n);
        }
    }

    public double pow(double x, int n){
        if(n == 0){
            return 1;
        }else if(n == 1){
            return x;
        }else{
            if( n % 2 == 0){
                double ans = pow(x, n/2);
                return ans * ans;
            }else{
                double ans = pow(x, (n-1)/2);
                return x * ans * ans;
            }
        }
    }

```

解法二：迭代

```java
    public double myPow(double x, int n) {
        long nLong = n;
        return nLong >= 0 ? quickMul(x, nLong) : 1.0 / quickMul(x, -nLong);
    }

    public double quickMul(double x, long n) {
        double ans = 1.0;
        while (n > 0) {
            if (n % 2 == 1) {
                ans *= x;
            }
            x *= x;
            n /= 2;
        }
        return ans;
    }
```

### 1.5.2 判断幂运算

- 判断该整数是否是 `2` 的[幂次方](https://leetcode-cn.com/problems/power-of-two/solution/)

通过`n&(n-1) == 0`去判断，`2`的幂次方则二进制只有一个位为 `1`

```java
    public boolean isPowerOfTwo(int n) {
        return n>0 && ( (n&(n-1)) == 0 );
    }
```



- 判断该整数是否是 `3` 的[幂次方](https://leetcode-cn.com/problems/power-of-three/solution/)

由于给定的输入 n 是 int 型，其最大值为 $2^{31}$，因此在int 型的数据范围内存在最大的 3 的幂，不超过 $2^{31}$的最大的 3 的幂是 $3^{19}=1162261467

如果 n 是 3 的幂，则 n>0，且存在非负整数 k 使得 $n=3^k$，又由于 $n \le 3^{19}$ ，因此 $k \le 19$，$3^{19}$ 一定能被 n 整除：$\frac{3^{19}}{n}=\frac{3^{19}}{3^k}=3^{19-k}$  为正整数。

如果 n 不是 3 的幂，则 n 一定包含除了 3 以外的质因数，又由于 $3^{19}$ 的质因数只有 3，因此 $3^{19}$ 不能被 n 整除。

综上所述，对于 int 型的 n，n 是 3 的幂，当且仅当 n>0 且 $3^{19}$ 能被 n 整除。

```java
    public boolean isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
```



- 判断该整数是否是 `4` 的幂次方

  [4次幂](https://leetcode-cn.com/problems/power-of-four/solution/)

正整数 n 是 2 的幂，当且仅当 n 的二进制表示中只有最高位是 1，其余位都是 0。如果 n 的二进制表示中只有最高位是 1，最高位后面有偶数个 0，则 n 是 4 的幂。

如何判断 n 是否满足最高位后面有偶数个 0 呢？可以通过位运算判断。如果 n 是 4 的幂，则有 $n \oplus 1010 \ldots 1010_{(2)}=0$，其中 ⊕ 表示按位异或，$1010 \ldots 1010_{(2)}=aaaaaaaa_{(16)}$ 

```java
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;
    }
```



### 1.5.3几何矩形重叠

- 判断[两个矩形是否重叠]( https://leetcode-cn.com/problems/rectangle-overlap/solution/)

只有当两个矩形的面积都大于 0 时，两个矩形才可能重叠。两个矩形的面积都大于 0 的条件是：

$\textit{rec}_1[0]<\textit{rec}_1[2]$

$\textit{rec}_1[1]<\textit{rec}_1[3]$

$\textit{rec}_2[0]<\textit{rec}_2[2]$

$\textit{rec}_2[1]<\textit{rec}_2[3]$
水平方向的坐标范围重叠，等价于 $\textit{rec}_1[2]>\textit{rec}_2[0]$ 且 $\textit{rec}_1[0]<\textit{rec}_2[2]$

竖直方向的坐标范围重叠，等价于 $\textit{rec}_1[3]>\textit{rec}_2[1]$且 $\textit{rec}_1[1]<\textit{rec}_2[3]$

```java
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if (rec1[0] == rec1[2] || rec1[1] == rec1[3] || rec2[0] == rec2[2] || rec2[1] == rec2[3]) {
            return false;
        }
        return rec1[2] > rec2[0] && rec1[0] < rec2[2] && rec1[3] > rec2[1] && rec1[1] < rec2[3];
    }
```

- 求两个矩形[重叠面积](https://leetcode-cn.com/problems/rectangle-area/solution/)

计算两个矩形的重叠部分的面积，可以利用[836. 矩形重叠](https://leetcode-cn.com/leetbook/read/bit-manipulation-and-math/on1nf3/)的思路，在判断两个矩形是否重叠的同时计算重叠部分的面积。

第一个矩形的左下角坐标是 (A,B)，右上角坐标是 (C,D)。第二个矩形的左下角坐标是 (E,F)，右上角坐标是 (G,H)

重叠部分的水平方向长度是 min(C,G) − max(A,E)；

重叠部分的竖直方向长度是 min(D,H) − max(B,F)。

```java
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int hg = 0, lg = 0;
        if( (ax1<bx2) && (ax2 > bx1) && (ay1 < by2) && (ay2 > by1) ){
        	hg = Math.min(ay2,by2) - Math.max(ay1,by1);
        	lg = Math.min(ax2,bx2) - Math.max(ax1,bx1);
        }
        int s1 = (ax2-ax1) * (ay2-ay1);
        int s2 = (bx2-bx1) * (by2-by1);
        return s1 + s2 - hg*lg;

    }
```



### 1.5.4 质数

**质数定义**
质数也称素数，其定义是：一个大于 1 的正整数，除了 1 和它自身以外没有其他的因数，则这个正整数为素数。

如果一个正整数除了 1 和它自身以外还有其他的因数，则这个正整数为合数。

1 既不是质数，也不是合数，而是单独的一类。

**质数的判定**
由于 11 既不是质数也不是合数，因此对于 1 可以直接判断其不是质数。以下只考虑对于大于 1 的正整数判定是不是质数。

如果正整数 n 是合数，则一定存在正整数 x,y，满足 1<x≤y 且 $x \times y=n$。由于 x≤y，因此一定有 $x \le \sqrt{n} \le y$，即如果正整数 n 是合数，一定存在正整数 x 满足 $1<x \le \sqrt{n}$且 x 能整除 n。

要判断一个正整数 n 是合数还是质数，只要遍历所有大于 1 且小于 $\sqrt{n}$  的正整数 x，判断是否存在正整数 x 可以整除 n，只要找到一个这样的 x，则 n 就是合数，否则 n 是质数。

具体实现方面可以进一步优化。由于 2 是偶数中唯一的质数，因此首先判断 n 的奇偶性，当 n 是偶数时根据 n 是否等于 2 判断 n 是质数还是合数，当 n 是奇数时再寻找可以整除 n 的 x，遍历 x 时只需要遍历奇数即可。

**分解质因数**
算术基本定理的表述为：任何一个大于 11 的正整数 nn，如果 nn 不是质数，那么 nn 可以唯一地分解成有限个质数的乘积。

$n=p_1^{\alpha_1} \times p_2^{\alpha_2} \times \ldots \times p_k^{\alpha_k}$

其中 $p_1<p_2<\ldots<p_k$ 都是质数，$\alpha_1,\alpha_2,\ldots,\alpha_k$  都是正整数。



[计数质数](https://leetcode-cn.com/problems/count-primes/solution/)

从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数，遍历结束的时候即可知道质数的个数

```java
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i]) {
                ++ans;
                if ((long) i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = false;
                    }
                }
            }
        }
        return ans;
    }
```







### 1.5.5 最大公约数和互质

最大公约数和互质的概念
如果正整数 c 同时是正整数 a 和 b 的约束，即正整数 a 和 b 都是正整数 c 的倍数，则称 c 是 a 和 b 的公约数。正整数 a 和 b 的公约数中的最大值为 a 和 b 的最大公约数，记为 gcd(a,b)。

计算最大公约数常用的算法是欧几里得算法：

当 b=0 时，gcd(a,b)=a；

当 $b \ne 0$时，$\gcd(a,b)=\gcd(b, a \bmod b)$。

如果正整数 a 和 b 的最大公约数是 1，则 a和 b 互质。



裴蜀定理
裴蜀定理的表述为：如果正整数 a 和 b 的最大公约数是 c，则对于任意的整数 x 和 y，ax+by 一定是 c 的倍数，特别地，一定存在整数 x 和 y 使得 ax+by=c。

裴蜀定理的一个重要推论是：正整数 a 和 b 互质地充分必要条件是存在整数 x 和 y 使ax+by=1。

裴蜀定理及其推论可以推广到多个数的情况。

[1250. 检查「好数组」](https://leetcode-cn.com/problems/check-if-it-is-a-good-array/)

一个正整数数组 `nums`，从中任选一些子集，将子集中每一个数乘以一个 **任意整数**，并求出他们的和为 1

这道题实质是裴蜀定理推广到多个数的情况。如果数组 nums 中的元素的最大公约数是 1，则 nums 是「好数组」，否则不是「好数组」

```java
    public boolean isGoodArray(int[] nums) {
        int tmp = nums[0];
        int len = nums.length;
        for(int i = 1; i < len; i++){
            tmp = gcd(tmp, nums[i]);
        }
        return tmp == 1;
    }

    public int gcd(int a, int b){
        if(b == 0){
            return a;
        }
        return gcd(b, a%b);
    }
```



### 1.5.6 排列组合

**组合数学**
组合数学是一门研究离散对象的科学。狭义的组合数学主要研究满足一定条件的组态（也称组合模型）的存在、计数以及构造等方面的问题。

**排列组合**
**加法原理**
如果完成一个任务的方法有 n 类，其中第 i 类方法有 $x_i$种不同的做法，则完成这个任务共有 $x_1+x_2+\ldots+x_n $种不同的做法。

例如，从起点到终点，乘坐公交车有 3 条线路，乘坐地铁有 2 条线路，则一共有 3+2=5 种不同的线路。

**乘法原理**
如果完成一个任务包含 n 个步骤，其中第 i 个步骤有 $x_i$种不同的做法，且这些做法彼此独立，则完成这个任务共有 $x_1 \times x_2 \times \ldots \times x_n $种不同的做法。

例如，从起点经过中转点到终点，从起点到中转点需要乘坐公交车，有 3 条线路，从中转点到终点需要乘坐地铁，有 2 条下路，则一共有 3×2=6 种不同的线路。

**排列数**
从 n 个不同的元素中依次取 m 个元素（m≤n），产生的不同排列的数量为：

$P_n^m=\frac{n!}{(n-m)!}=n \times (n-1) \times \ldots \times (n-m+1)$

其中 n! 表示 n 的阶乘。

**组合数**
从 n 个不同的元素中任取 m 个元素（m≤n），产生的不同组合的数量为：

$C_n^m=\frac{P_n^m}{m!}=\frac{n!}{m!(n-m)!}=\frac{n \times (n-1) \times \ldots \times (n-m+1)}{m \times (m-1) \times \ldots \times 1}$

 

**组合数性质**
组合数的性质较多，此处列举两个重要的性质。

组合数递推公式：$C_n^m=C_{n-1}^{m-1}+C_{n-1}^m$。

二项式定理：$(x+y)^n=\sum_{k=0}^n C_n^k x^k y^{n-k}(x+y)$



[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？
>

```java
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
```





[杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/solution/)

从左上角到右下角的过程中，我们需要移动 m+n-2次，其中有 m-1次向下移动，n-1次向右移动。因此路径的总数，就等于从 m+n-2 次移动中选择 m-1次向下移动的方案数，即组合数：${\Large C}_{m+n-2}^{m-1} = \binom{m+n-2}{m-1} = \frac{(m+n-2)(m+n-3)\cdots n}{(m-1)!} = \frac{(m+n-2)!}{(m-1)!(n-1)!}$

```java
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
```





```java
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        
        for(int i = 0; i < numRows; i++){
            List<Integer> row = new ArrayList<Integer>();
            for(int j = 0; j < i+1; j++){
                if(j == 0 || j == i){
                    row.add(1);
                }else{
                    row.add( list.get(i-1).get(j-1) + list.get(i-1).get(j) );
                }
            }
            list.add(row);

        }
        return list;
```







# 2. 查找

## 2.1 二分查找

### 2.1.1 二分查找两种基本写法的差异
- 写法一

```java
		// 获取最左边位置
       while(l < r){
            int mid = l + (r - l) / 2;
            if(target > nums[mid]){
                l = mid + 1;
            } else {
                r = mid;
            }
        }
```
这种写法里面`mid = l + (r - l) / 2`，其中`l = mid + 1`，`mid`最大值为`r-1`
二分查找里面主要是防止出现死循环，假设更换`l=mid+1`为`l=mid`，当`l = r-1`时，如果此时`mid = r-1`，就会出现`[r-1, r]`的死循环
为了防止出现，则`mid = r-1`时，`l=mid+1` ==>`[r, r]`此时循环就会结束



- 写法二

```java
		// 获取最右边位置
        while(l < r){
            int mid = l + (r - l + 1) / 2;
            if(target < nums[mid]){
                r = mid - 1;
            }else{
                l = mid;
            }
        }
```
假设仍然用写法一里面`mid = l + (r - l) / 2`，`mid`最大值为`r-1`

此时`l=mid`这个不去改变，肯定存在`l = r-1`时，然后带入`mid = l+(r-l)/2 = r-1 + (r-r+1)/2 = r-1`，然后`l = mid = r-1`，此时又出现了`l=r-1`，进入死循环

为了避免这种情况，我们需要改变为`mid = l + (r - l + 1)/2`，这样当`l=r-1`时，`mid=r`，直接结束循环。



### 2.1.2 二分查找找不同位置情况划分

#### 2.1.2.1 找相同的target

- 找最左侧target

`target > nums[mid]`作为条件，则即使`target == nums[mid]`也会`r=mid`来不断的向左移动，直到最左边
```java
        int[] nums = new int[]{3,6,6,6,6,7,11};
        int target = 6;
        int l = 0, r = nums.length-1;

        while(l < r){
            int mid = l+(r-l)/2;
            System.out.println("l: " + l + " mid: " + mid +" r:"+r);
            if(nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }

        System.out.println("target position: " + l);
```

```
l: 0 mid: 3 r:6
l: 0 mid: 1 r:3
l: 0 mid: 0 r:1
target position: 1
```

- 找最右侧target

`target < nums[mid]`作为条件，则即使`target == nums[mid]`也会`l=mid`来不断的向右移动，直到最右边
```java
        int[] nums = new int[]{3,6,6,6,6,7,11};
        int target = 6;
        int l = 0, r = nums.length-1;

        while(l < r){
            int mid = l+(r-l+1)/2;
            System.out.println("l: " + l + " mid: " + mid +" r:"+r);
            if(nums[mid] > target) {
                r = mid - 1;
            } else {
                l = mid;
            }
        }
        System.out.println("target position:" + l);
```
遍历结果：
```
l: 0 mid: 3 r:6
l: 3 mid: 5 r:6
l: 3 mid: 4 r:4
target position:4
```


#### 2.1.2.2 找target插入位置
此时**修改找左侧相同target**的写法一中`r = nums.length`则可以扩大搜索范围，如果大于任何一个数则插入最后
```java
        int[] nums = new int[]{3,6,6,6,6,7,11};
        int target = 12;
        int l = 0, r = nums.length;

        while(l < r){
            int mid = l+(r-l)/2;
            System.out.println("l: " + l + " mid: " + mid +" r:"+r);
            if(nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }

        System.out.println("target position: " + l);
```

```
l: 0 mid: 3 r:7
l: 4 mid: 5 r:7
l: 6 mid: 6 r:7
target position: 7
```

但是需要注意的是这里**不能使用找右侧相同target**的方法去写，会出现溢出的情况，当达到最大`mid = nums.length`，此时就会出现`nums[mid]`报错
	```
l: 0 mid: 4 r:7
l: 4 mid: 6 r:7
l: 6 mid: 7 r:7   // 这里报错
	```



### 2.1.3 二分查找迭代改递归

```java
class Solution {
    public int findMin(int[] nums) {
        return findMin(nums, 0, nums.length-1);
    }

    public int findMin(int[] nums, int l, int r){
        if(l == r){   // 递归终止条件
            return nums[l];
        }

        int mid = l + (r-l)/2;
        if(nums[mid] <= nums[r]){
            return findMin(nums, l, mid);
        }else{
            return findMin(nums, mid+1, r);
        }
    }
}
```









# 3. 排序

## 冒泡排序

```java
    public void bubble(){
        int[] nums = new int[]{6,2,1,3,5,4};
        int len = nums.length;
        boolean isSwap = false;
        for(int i = 0; i < len -1 ; i++){
            isSwap = false;
            for(int j = 0; j < len - 1- i; j++){
                if(nums[j] > nums[j+1]){
                    swap(nums, j, j+1);
                    isSwap = true;
                }
            }
            // 优化：当遍历一遍后没有发生改变则停止遍历
            if(! isSwap){
                break;
            }
        }
        System.out.println(Arrays.toString(nums));
    }

    public void swap(int[] nums, int a, int b){
        nums[a] = nums[a] + nums[b];
        nums[b] = nums[a] - nums[b];
        nums[a] = nums[a] - nums[b];
    }
```









## 选择排序

```java
public int[] sortArray(int[] nums) {
        int len = nums.length;
        // 最后一轮只有一个元素，一定是最大的元素，因此写 i < len - 1
        for (int i = 0; i < len - 1; i++) {
            // 在 [i + 1, len - 1] 区间里选择最小的元素的下标
            int minIndex = i;
            for (int j = i + 1; j < len; j++) {
                if (nums[j] < nums[minIndex]) {
                    minIndex = j;
                }
            }
            swap(nums, minIndex, i);
        }
        return nums;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
```



## 插入排序

基础版本

```java
    public void InsertSort1(){
        int[] nums = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        int n = nums.length;
        for(int i = 1; i < n; i++){
            int j = i, tmp = nums[i];
            while(j > 0 && nums[j-1] > tmp ){
                nums[j] = nums[j-1];
                j--;
            }
            nums[j] = tmp;
        }
        System.out.println(Arrays.toString(nums));

    }

```

在内层循环里都有` j > 0 `这个判断条件，有一种插入排序的写法，先找到整个数组中最小的那个元素，把它交换到数组的第 1 个位置（下标为 0），后面的逻辑就可以去掉 `j > 0`。

使用哨兵后

```java
	public void InsertSort2(){
        int[] nums = new int[]{6, 5, 3, 1, 8, 7, 2, 4};
        int n = nums.length;
        // 找最小值
        int minIndex = 0;
        for(int i = 0; i < n; i++){
            if(nums[i] < nums[minIndex]){
                minIndex = i;
            }
        }
        // 将最小值交换到第一个
        swap(nums, 0, minIndex);
        System.out.println(Arrays.toString(nums));

        // 在已有哨兵情况下交换排序
        for(int i = 1; i < n; i++){
            int j = i;
            int tmp = nums[j];
            while(nums[j-1] > tmp){
                nums[j] = nums[j-1];
                j--;
            }
            nums[j] = tmp;
        }
        System.out.println(Arrays.toString(nums));

    }
```







## 归并排序

```java

public class MergeSort {

    public int[] sortArray(int[] nums){
        int n = nums.length;
        mergeSort(nums, 0, n-1);
        return nums;
    }

    public void mergeSort(int[] nums, int l, int r){
        // 递归终止条件
        if(l == r){
            return;
        }

        // 递归分割
        int mid = l + (r - l) / 2;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid+1, r);

        //合并两个数组并使用双指针按顺序排列
        mergeArrays(nums, l, mid, r);

    }

    public void mergeArrays(int[] nums, int l, int mid, int r){
        int len = r - l + 1;
        int [] tmp = new int[len];
        for(int i = 0; i < len; i++){
            tmp[i] = nums[l+i];
        }

        int i = 0, j = mid - l + 1;
        for(int k = 0; k < len; k++){
            if(i == mid - l + 1){
                nums[l+k] = tmp[j];
                j++;
            }else if(j == len){
                nums[l+k] = tmp[i];
                i++;
            }else if(tmp[i] <= tmp[j]){
                nums[l+k] = tmp[i];
                i++;
            }else{
                nums[l+k] = tmp[j];
                j++;
            }
        }
    }

    @Test
    public void test(){
        int[] nums = new int[]{8,6,7,5,4,3,2,1};
        sortArray(nums);
        System.out.println(Arrays.toString(nums));
    }
}
```



## 快速排序

```java

import java.util.Random;

public class QuickSort {
    public void Sort(int[] nums){
        int len = nums.length;
        quickSort(nums, 0, len-1);
        System.out.println(Arrays.toString(nums));
    }

    public void quickSort(int[] nums, int l, int r){
        if(l >= r){
            return;
        }
        int mid = partition(nums, l, r);
        quickSort(nums, l, mid-1);
        quickSort(nums, mid+1, r);
    }

    public int partition(int[] nums, int l, int r){
        int rand = l + new Random().nextInt(r-l+1);
        swap(nums, l, rand);
        int pivot = nums[l];
        int lt = l;
        for(int i = l+1; i <= r; i++ ){
            if(nums[i] < pivot){
                lt++;
                swap(nums, i, lt);
            }
        }
        swap(nums, lt, l);

        return lt;
    }

    public void swap(int[] nums, int a, int b){
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }

    @Test
    public void test(){
        int[] nums = new int[]{4,5,1,6,7,3,2};
        Sort(nums);
    }

}
```



## 堆排序

![初始化堆](https://assets.leetcode-cn.com/solution-static/912_fig2.gif)

![交换元素](https://assets.leetcode-cn.com/solution-static/912_fig3.gif)

将根节点的下标视为 `0`，则完全二叉树有如下性质：

- 对于完全二叉树中的第 `i` 个数，它的左子节点下标：`left = 2i + 1`
- 对于完全二叉树中的第 `i` 个数，它的右子节点下标：`right = left + 1`
- 对于有 `n` 个元素的完全二叉树`(n≥2)`，它的最后一个非叶子结点的下标：`n/2 - 1`





```java
public static void heapSort(int[] arr) {
    // 构建初始大顶堆
    buildMaxHeap(arr);
    for (int i = arr.length - 1; i > 0; i--) {
        // 将最大值交换到数组最后
        swap(arr, 0, i);
        // 调整剩余数组，使其满足大顶堆
        maxHeapify(arr, 0, i);
    }
}
// 构建初始大顶堆
private static void buildMaxHeap(int[] arr) {
    // 从最后一个非叶子结点开始调整大顶堆，最后一个非叶子结点的下标就是 arr.length / 2-1
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        maxHeapify(arr, i, arr.length); // 注意这里是arr.length
    }
}
// 调整大顶堆，第三个参数表示剩余未排序的数字的数量，也就是剩余堆的大小
private static void maxHeapify(int[] arr, int i, int heapSize) {
    // 左子结点下标
    int l = 2 * i + 1;
    // 右子结点下标
    int r = l + 1;
    // 记录根结点、左子树结点、右子树结点三者中的最大值下标
    int largest = i;
    // 与左子树结点比较
    if (l < heapSize && arr[l] > arr[largest]) {
        largest = l;
    }
    // 与右子树结点比较
    if (r < heapSize && arr[r] > arr[largest]) {
        largest = r;
    }
    if (largest != i) {
        // 将最大值交换为根结点
        swap(arr, i, largest);
        // 再次调整交换数字后的大顶堆
        maxHeapify(arr, largest, heapSize);
    }
}
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```





