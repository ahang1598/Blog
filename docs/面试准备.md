

# 1.自我介绍

我是来自暨南大学 - 网络空间安全专业一名研究生，目前研二。

研究方向是城市数据挖掘，目前已经发表了一篇CCF-C类国际会议一篇，获2021校级优秀研究生三等奖。

现在希望参加招聘尽早出去实习，如果可以的话四月份就可以出去实习。

本科GPA3.0 / 4， 研究生GPA3.24 / 4



# 2. 项目

## 2.1 介绍该项目

首先呢，选择这个开源的电商项目主要由于电商的技术点比较多而且新，电商的市场份额也很大。这个前后端分离的项目可以学习到SpringBoot的应用，微服务架构，分布式架构以及相关的项目管理。

这个项目大概实现功能是：

当用户访问时，进行权限校验，验证通过后访问商城信息，可以检索、选择所需商品并下单购买。也提供秒杀抢购业务。

当后台管理员访问通过权限校验后，可以上传更改商品信息。

学完这个项目后，对于项目业务开发的基本流程有了一个了解，对于SpringBoot框架应用，各个微服务在Eureka集群注册后通过Feign调用服务的方便快捷有一定了解。 以及采用RabbitMQ延迟队列机制及设计Redis对商品信息、商品库存量、用户信息高效存储，实现多线程异步秒杀，解决重复排队，超卖等问题。



## 2.2 项目痛点



### 2.2.1出现过哪些问题？

下订单时

```java
发送了一个post请求
http://localhost:18090/order

提交测试数据
{
	"receiverContact" : "szitheima",
	"receiverMobile" : "12345",
	"receiverAddress" : "hahaha"
} 
```

返回了500错误，同时也返回了错误的信息：

表示无法读取`http://goods/sku/decr/count?username=szitheima`

```java

{
    "timestamp": "2022-03-22T08:57:16.689+0000",
    "status": 500,
    "error": "Internal Server Error",
    "message": "Read timed out executing POST http://goods/sku/decr/count?username=szitheima",
    "path": "/order"
}
```

订单的  `OrderController`调用了`orderService.add(order);`，其中`orderServiceImpl`实现中调用了`skuFeign.decrCount(order.getUsername());`

考虑是否为商品微服务没有启动导致微服务无法调用，发现已经启动了，那么就查看商品微服务

查看商品微服务时：`decrCount()`方法会去调用redis缓存数据，那么此时我就去查看redis的缓存是否存在用户的购物车数据，发现没有。

问题最终定位到：对于购物车数据设置了缓存过期时间，导致数据到期后消失，我测试时直接读取下单，没有调用购物车数据，导致了问题。

临时解决：重新添加用户的购物车数据。

永久解决：规范流程，用户先通过购物车页面点选后将购物车数据加载到redis缓存中，然后下单开始减少库存。





### 2.2.2 出现问题后如何解决？

**BUG定位**

1. 对于web服务先明确是浏览器端问题还是服务端问题，通过状态返回码基本定位，检查输入的URL是否与后端提供的API一致。
2. 对于500服务端问题，查看IDEA的异常日志信息，是否有错误报出
3. 有异常时，考虑是内部逻辑问题还是输入数据问题？基本检查下逻辑是否正确，有没有临界值问题，配置问题问题？然后通过调试DEBUG打断点。对于出现问题前的代码打断点，不断调试查看数据是否传递计算正常。
4. 也有其他原因：是否和服务器软件版本及设置有关？













## 2.3 秒杀



**如何控制秒杀商品页面购买按钮的点亮**

控制该按钮是灰色还是点亮，但是为了减轻服务器端负载压力，更好地利用CDN、反向代理等性能优化手段，该页面被设计为静态页面，缓存在CDN、反向代理服务器上，甚至用户浏览器上。秒杀开始时，用户刷新页面，请求根本不会到达应用服务器。

采用Spring的定时任务定时将符合参与秒杀的商品查询出来再存入到Redis缓存，所以这里需要使用到定时任务。**在定时任务类的指定方法上加上@Scheduled开启定时任务**



redis应用一：下单实现

用户下单，为了提升下单速度，我们将订单数据存入到Redis缓存中，如果用户支付了，则将Reids缓存中的订单存入到MySQL中，并清空Redis缓存中的订单。



多线程下单

下订单这里，我们一般采用多线程下单，但多线程中我们又需要保证用户抢单的公平性，也就是先抢先下单。我们可以这样实现，用户进入秒杀抢单，如果用户复合抢单资格，只需要记录用户抢单数据，存入队列，多线程从队列中进行消费即可，存入队列采用左压，多线程下单采用右取的方式。

先开启异步操作，用`@EnableAsync`注解开启，然后在对应的异步方法上添加注解`@Async`即可。

**排队信息封装**

用户每次下单的时候，我们可以创建一个队列进行排队，然后采用多线程的方式创建订单，排队我们可以采用Redis的队列实现。 排队信息中需要有用户抢单的商品信息，主要包含商品ID，商品抢购时间段，用户登录名。

**下单更新抢单状态**

用户每次点击抢购的时候，如果排队成功，则将用户抢购状态存储到Redis中，多线程抢单的时候，如果抢单成功，则更新抢单状态。



防止重复下单排队

用户每次抢单的时候，一旦排队，我们设置一个自增值，让该值的初始值为1，每次进入抢单的时候，对它进行递增，如果值>1，则表明已经排队,不允许重复排队,如果重复排队，则对外抛出异常，并抛出异常信息100表示已经正在排队



**减库存的操作**

有两种选择，一种是**拍下减库存** 另外一种是**付款减库存**；目前采用的**“拍下减库存”**的方式，拍下就是一瞬间的事，对用户体验会好些。



**并发超卖问题解决**

原因：只剩下一个库存时，多线程同时读取都有库存，导致都下单成功

解决：

1）可以利用Redis队列实现，给每件商品创建一个独立的商品个数队列，每次给用户下单的时候，先从队列中取数据，如果能取到数据，则表明有库存，如果取不到，则表明没有库存，这样就可以防止超卖问题产生了。

2）利用悲观锁，对商品库存加锁，这样会导致效率低，多个线程等待一个锁

3）利用乐观锁，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。**它会增大CPU的计算开销**







https://www.jianshu.com/p/df4fbecb1a4b





## 2.4 正向索引和倒排索引

Lucene和ElasticSearch
lucene:全文搜索工具包，依赖于java，不适用于集群环境
ES：全文搜索服务器，基于lucene，采用Rest HTTP调用方式，对集群支持较好



**正向索引**：逐个扫描文档，匹配出关键词

**当用户在主页上搜索关键词“小米手机”时，假设只存在正向索引（forward index），那么就需要扫描索引库中的所有文档，找出所有包含关键词“小米手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。**因为互联网上收录在搜索引擎中的文档的数目是个天文数字，**这样的索引结构根本无法满足实时返回排名结果的要求。**



![](img\Interview\855959-20170706154309815-1724421988.png)



**倒排索引**：主要是**根据关键字建立索引**，然后根据关键字找到关键字对应的**排好序的字典**，通过有序字典就可以很快（ O(log n) ）找到对应的**文件列表**

![](img\Interview\inverted-index.png)

![](img\Interview\index.png)

​    **所以，搜索引擎会将正向索引重新构建为倒排索引**，即把文件ID对应到关键词的映射转换为**关键词到文件ID的映射**，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。![](img\Interview\855959-20170706154505378-610589524.png)

posting list也有压缩Frame Of Reference

第一步：对递增的数组，求出两两差值

第二步：分块存储

第三步：找出每一块最大需要的比特数，比如第一块最大227需要8比特，那么三个就需要3*8bits

![](img\Interview\frameOfReference.png)

**联合查询**

如果多个field索引的联合查询，倒排索引如何满足快速查询的要求呢？

- 利用跳表(Skip list)的数据结构快速做“与”运算，或者
- 利用上面提到的bitset按位“与”



# 3.优点







漏桶算法

https://www.cnblogs.com/xuwc/p/9123078.html



## B+树时间复杂度

 https://zhuanlan.zhihu.com/p/402951795

一个含有`n`个值，阶为`m`的B+树: $log_mn$

通过这个可以定位到子节点，对子节点读取时是一次IO全部读取，不需要考虑子节点遍历问题了。



B+树详解http://t.csdn.cn/idBcv

![](img\Interview\20200420151803292.png)



# 并发

## 线程池

什么是线程池？

线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。

如果每个请求都创建一个线程去处理，那么服务器的资源很快就会被耗尽，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

 

为什么要使用线程池？

创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）

 

线程池有什么作用？

线程池作用就是限制系统中执行线程的数量。

1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。

2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。

 

说说几种常见的线程池及使用场景

1、newSingleThreadExecutor

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

2、newFixedThreadPool

创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

3、newCachedThreadPool

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

4、newScheduledThreadPool

创建一个定长线程池，支持定时及周期性任务执行。

 

线程池中的几种重要的参数

corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收

maximumPoolSize就是线程池中可以容纳的最大线程的数量

keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清                                除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，

util，就是计算这个时间的一个单位。

workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。

threadFactory，就是创建线程的线程工厂。

handler,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。

 

说说线程池的拒绝策略

    当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor中已经包含四种处理策略。

AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。

CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。

DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。

DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。

    除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现RejectedExecutionHandler接口即可。

 


execute和submit的区别？

    在前面的讲解中，我们执行任务是用的execute方法，除了execute方法，还有一个submit方法也可以执行我们提交的任务。

这两个方法有什么区别呢？分别适用于在什么场景下呢？我们来做一个简单的分析。

execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以了。

submit方法适用于需要关注返回值的场景

 

五种线程池的使用场景

newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。

newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。

newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。

newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。

newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。

 

线程池的关闭

关闭线程池可以调用shutdownNow和shutdown两个方法来实现

shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。

shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。

 

初始化线程池时线程数的选择

如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。

如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。

上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。

 

线程池都有哪几种工作队列

1、ArrayBlockingQueue

是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。

2、LinkedBlockingQueue

一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列

3、SynchronousQueue

一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。

4、PriorityBlockingQueue

一个具有优先级的无限阻塞队列。
————————————————
版权声明：本文为CSDN博主「Linias」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_29373285/article/details/85238728



**线程池大小**

如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1

如果是IO密集型任务，参考值可以设置为2*NCPU

![](img\Interview\threadNums.png)



